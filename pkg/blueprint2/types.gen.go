// Package blueprint2 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package blueprint2

import (
	"encoding/json"
	"fmt"

	"github.com/oapi-codegen/runtime"
)

// Defines values for BlueprintInstallerAnacondaDisabledModules.
const (
	BlueprintInstallerAnacondaDisabledModulesOrgFedoraprojectAnacondaModulesLocalization BlueprintInstallerAnacondaDisabledModules = "org.fedoraproject.Anaconda.Modules.Localization"
	BlueprintInstallerAnacondaDisabledModulesOrgFedoraprojectAnacondaModulesNetwork      BlueprintInstallerAnacondaDisabledModules = "org.fedoraproject.Anaconda.Modules.Network"
	BlueprintInstallerAnacondaDisabledModulesOrgFedoraprojectAnacondaModulesPayloads     BlueprintInstallerAnacondaDisabledModules = "org.fedoraproject.Anaconda.Modules.Payloads"
	BlueprintInstallerAnacondaDisabledModulesOrgFedoraprojectAnacondaModulesRuntime      BlueprintInstallerAnacondaDisabledModules = "org.fedoraproject.Anaconda.Modules.Runtime"
	BlueprintInstallerAnacondaDisabledModulesOrgFedoraprojectAnacondaModulesSecurity     BlueprintInstallerAnacondaDisabledModules = "org.fedoraproject.Anaconda.Modules.Security"
	BlueprintInstallerAnacondaDisabledModulesOrgFedoraprojectAnacondaModulesServices     BlueprintInstallerAnacondaDisabledModules = "org.fedoraproject.Anaconda.Modules.Services"
	BlueprintInstallerAnacondaDisabledModulesOrgFedoraprojectAnacondaModulesStorage      BlueprintInstallerAnacondaDisabledModules = "org.fedoraproject.Anaconda.Modules.Storage"
	BlueprintInstallerAnacondaDisabledModulesOrgFedoraprojectAnacondaModulesSubscription BlueprintInstallerAnacondaDisabledModules = "org.fedoraproject.Anaconda.Modules.Subscription"
	BlueprintInstallerAnacondaDisabledModulesOrgFedoraprojectAnacondaModulesTimezone     BlueprintInstallerAnacondaDisabledModules = "org.fedoraproject.Anaconda.Modules.Timezone"
	BlueprintInstallerAnacondaDisabledModulesOrgFedoraprojectAnacondaModulesUser         BlueprintInstallerAnacondaDisabledModules = "org.fedoraproject.Anaconda.Modules.User"
)

// Defines values for BlueprintInstallerAnacondaEnabledModules.
const (
	BlueprintInstallerAnacondaEnabledModulesOrgFedoraprojectAnacondaModulesLocalization BlueprintInstallerAnacondaEnabledModules = "org.fedoraproject.Anaconda.Modules.Localization"
	BlueprintInstallerAnacondaEnabledModulesOrgFedoraprojectAnacondaModulesNetwork      BlueprintInstallerAnacondaEnabledModules = "org.fedoraproject.Anaconda.Modules.Network"
	BlueprintInstallerAnacondaEnabledModulesOrgFedoraprojectAnacondaModulesPayloads     BlueprintInstallerAnacondaEnabledModules = "org.fedoraproject.Anaconda.Modules.Payloads"
	BlueprintInstallerAnacondaEnabledModulesOrgFedoraprojectAnacondaModulesRuntime      BlueprintInstallerAnacondaEnabledModules = "org.fedoraproject.Anaconda.Modules.Runtime"
	BlueprintInstallerAnacondaEnabledModulesOrgFedoraprojectAnacondaModulesSecurity     BlueprintInstallerAnacondaEnabledModules = "org.fedoraproject.Anaconda.Modules.Security"
	BlueprintInstallerAnacondaEnabledModulesOrgFedoraprojectAnacondaModulesServices     BlueprintInstallerAnacondaEnabledModules = "org.fedoraproject.Anaconda.Modules.Services"
	BlueprintInstallerAnacondaEnabledModulesOrgFedoraprojectAnacondaModulesStorage      BlueprintInstallerAnacondaEnabledModules = "org.fedoraproject.Anaconda.Modules.Storage"
	BlueprintInstallerAnacondaEnabledModulesOrgFedoraprojectAnacondaModulesSubscription BlueprintInstallerAnacondaEnabledModules = "org.fedoraproject.Anaconda.Modules.Subscription"
	BlueprintInstallerAnacondaEnabledModulesOrgFedoraprojectAnacondaModulesTimezone     BlueprintInstallerAnacondaEnabledModules = "org.fedoraproject.Anaconda.Modules.Timezone"
	BlueprintInstallerAnacondaEnabledModulesOrgFedoraprojectAnacondaModulesUser         BlueprintInstallerAnacondaEnabledModules = "org.fedoraproject.Anaconda.Modules.User"
)

// Defines values for BlueprintNetworkFirewallServicesProtocol.
const (
	Any BlueprintNetworkFirewallServicesProtocol = "any"
	Tcp BlueprintNetworkFirewallServicesProtocol = "tcp"
	Udp BlueprintNetworkFirewallServicesProtocol = "udp"
)

// Blueprint Image Builder new blueprint schema.
//
// THIS IS WORK IN PROGRESS
type Blueprint struct {
	Accounts *struct {
		// Groups Operating system group accounts to be created on the image.
		Groups *[]struct {
			// Gid The group ID (GID) of the group.
			Gid *int `json:"gid,omitempty"`

			// Name Group name. Accepted characters: lowercase letters, digits, underscores, dollars, and hyphens. Name must not start with a hyphen. Maximum length is 256 characters. The validation pattern is a relaxed version of https://github.com/shadow-maint/shadow/blob/master/lib/chkname.c
			Name string `json:"name"`
		} `json:"groups"`

		// Users Operating system user accounts to be created on the image.
		Users *[]struct {
			// Description A longer description of the account.
			Description *string `json:"description,omitempty"`

			// Expires Date type which accepts date (YYYY-MM-DD) or date-time (RFC3339) format and only marshals into date format. This is needed for JSON/YAML compatibility since YAML automatically converts strings which look like dates into time.Time.
			Expires *string `json:"expires,omitempty"`

			// Gid The primary group ID (GID) of the user. Value of zero (or ommited value) means that the next available UID will be assigned.
			Gid *int `json:"gid,omitempty"`

			// Groups Additional groups that the user should be a member of.
			Groups *[]string `json:"groups,omitempty"`

			// Home The home directory of the user.
			Home *string `json:"home,omitempty"`

			// Name Account name. Accepted characters: lowercase letters, digits, underscores, dollars, and hyphens. Name must not start with a hyphen. Maximum length is 256 characters. The validation pattern is a relaxed version of https://github.com/shadow-maint/shadow/blob/master/lib/chkname.c
			Name string `json:"name"`

			// Password Password either in plain text or encrypted form. If the password is not provided, the account will be locked and the user will not be able to log in with a password. The password can be encrypted using the crypt(3) function. The format of the encrypted password is $id$salt$hashed, where $id is the algorithm used (1, 5, 6, or 2a).
			Password *string `json:"password,omitempty"`

			// Shell The shell of the user.
			Shell *string `json:"shell,omitempty"`

			// SshKeys SSH keys to be added to the account's authorized_keys file.
			SshKeys *[]string `json:"ssh_keys,omitempty"`

			// Uid The user ID (UID) of the user. Value of zero (or ommited value) means that the next available UID will be assigned.
			Uid *int `json:"uid,omitempty"`
		} `json:"users"`
	} `json:"accounts,omitempty"`

	// Cacerts The CA certificates to be added to the image. The certificates are added to the system-wide CA trust store. The certificates are added to the /etc/pki/ca-trust/source/anchors/ directory and the update-ca-trust command is run to update the system-wide CA trust store.
	Cacerts *[]struct {
		// Cert The PEM-encoded certificate.
		Cert string `json:"cert"`
	} `json:"cacerts"`

	// Containers Containers to be pulled during the image build and stored in the image at the default local container storage location that is appropriate for the image type, so that all supported container tools like podman and cri-o will be able to work with it. The embedded containers are not started, to do so you can create systemd unit files or quadlets with the files customization.
	Containers *[]struct {
		// LocalStorage Whether to pull the container image from the host's local-storage.
		LocalStorage *bool `json:"local_storage,omitempty"`

		// Name Container name is an optional string to set the name under which the container image will be saved in the image. If not specified name falls back to the same value as source.
		Name string `json:"name"`

		// Source Container image URL is a reference to a container image at a registry.
		Source    string `json:"source"`
		TlsVerify *bool  `json:"tls_verify"`
	} `json:"containers"`

	// Description The description attribute is a string that can be a longer description of the blueprint and is only used for display purposes.
	Description *string `json:"description,omitempty"`
	Dnf         *struct {
		// Groups Groups to install, must match exactly. Groups describes groups of packages to be installed into the image. Package groups are defined in the repository metadata. Each group has a descriptive name used primarily for display in user interfaces and an ID more commonly used in kickstart files. Here, the ID is the expected way of listing a group. Groups have three different ways of categorizing their packages: mandatory, default, and optional. For the purposes of blueprints, only mandatory and default packages will be installed. There is no mechanism for selecting optional packages.
		Groups *[]string `json:"groups"`

		// ImportKeys Additional file paths to the GPG keys to import. The files must be present in the image. Does not support importing from URLs.
		ImportKeys *[]string `json:"import_keys"`

		// Modules Modules to enable or disable
		Modules *[]string `json:"modules"`

		// Packages Packages to install. Package name or NVRA is accepted as long as DNF can resolve it. Examples: vim-enhanced, vim-enhanced-9.1.866-1 or vim-enhanced-9.1.866-1.fc41.x86_64. The packages can also be specified as @group_name to install all packages in the group.
		Packages *[]string `json:"packages"`

		// Repositories Third-party repositories are supported by the blueprint customizations.
		//
		// All fields reflect configuration values of dnf, see man dnf.conf(5) for more information.
		Repositories *[]Blueprint_Dnf_Repositories_Item `json:"repositories"`
	} `json:"dnf,omitempty"`
	Fips *struct {
		// Enabled Enables the system FIPS mode (disabled by default). Currently only edge-raw-image, edge-installer, edge-simplified-installer, edge-ami and edge-vsphere images support this customization.
		Enabled *bool `json:"enabled,omitempty"`
	} `json:"fips,omitempty"`

	// Fsnodes File system nodes details.
	//
	// You can use the customization to create new files or to replace existing ones, if not restricted by the policy specified below. If the target path is an existing symlink to another file, the symlink will be replaced by the custom file.
	//
	// Please note that the parent directory of a specified file must exist. If it does not exist, the image build will fail. One can ensure that the parent directory exists by specifying "ensure_parents".
	//
	// In addition, the following files are not allowed to be created or replaced by policy: /etc/fstab, /etc/shadow, /etc/passwd and /etc/group.
	//
	// Using the files customization comes with a high chance of creating an image that doesn't boot. Use this feature only if you know what you are doing. Although the files customization can be used to configure parts of the OS which can also be configured by other blueprint customizations, this use is discouraged. If possible, users should always default to using the specialized blueprint customizations. Note that if you combine the files customizations with other customizations, the other customizations may not work as expected or may be overridden by the files customizations.
	//
	// You can create custom directories as well. The existence of a specified directory is handled gracefully only if no explicit mode, user or group is specified. If any of these customizations are specified and the directory already exists in the image, the image build will fail. The intention is to prevent changing the ownership or permissions of existing directories.
	Fsnodes *[]Blueprint_Fsnodes_Item `json:"fsnodes"`

	// Hostname Hostname is an optional string that can be used to configure the hostname of the final image.
	Hostname  *string             `json:"hostname,omitempty"`
	Ignition  *Blueprint_Ignition `json:"ignition,omitempty"`
	Installer *struct {
		Anaconda *struct {
			DisabledModules *[]BlueprintInstallerAnacondaDisabledModules `json:"disabled_modules"`
			EnabledModules  *[]BlueprintInstallerAnacondaEnabledModules  `json:"enabled_modules"`
			Kickstart       *Blueprint_Installer_Anaconda_Kickstart      `json:"kickstart,omitempty"`

			// SudoNopasswd Sudo users with NOPASSWD option. Adds a snippet to the kickstart file that, after installation, will create drop-in files in /etc/sudoers.d to allow the specified users and groups to run sudo without a password (groups must be prefixed with %).
			SudoNopasswd *[]string `json:"sudo_nopasswd,omitempty"`

			// Unattended Unattended installation Anaconda flag. When not set, Anaconda installer will ask for user input.
			Unattended *bool `json:"unattended,omitempty"`
		} `json:"anaconda,omitempty"`
		Coreos *struct {
			// InstallationDevice Installation device for iot/edge simplified installer image types.
			InstallationDevice *string `json:"installation_device,omitempty"`
		} `json:"coreos,omitempty"`
	} `json:"installer,omitempty"`
	Kernel *struct {
		// CmdlineAppend An optional string to append arguments to the bootloader kernel command line. The list will be concatenated with spaces.
		CmdlineAppend *[]string `json:"cmdline_append"`

		// Package Kernel DNF package name to replace the standard kernel with.
		Package *string `json:"package,omitempty"`
	} `json:"kernel,omitempty"`
	Locale *struct {
		// Keyboards The keyboards attribute is a list of strings that contains the keyboards to be installed on the image. To list available keyboards, run: localectl list-keymaps
		Keyboards *[]string `json:"keyboards"`

		// Languages The languages attribute is a list of strings that contains the languages to be installed on the image. To list available languages, run: localectl list-locales
		Languages *[]string `json:"languages"`
	} `json:"locale,omitempty"`

	// Name The name attribute is a string that contains the name of the blueprint. It can contain spaces, but they may be converted to dash characters during build. It should be short and descriptive.
	Name    string `json:"name"`
	Network *struct {
		Firewall *struct {
			// Services Services to enable or disable. The service can be defined via an assigned IANA name, port number or port range.
			//
			// Services are processed in order, when a service is disabled and then accidentally enabled via a port or a port range, the service will be enabled in the end.
			//
			// By default the firewall blocks all access, except for services that enable their ports explicitly such as the sshd.
			Services *[]Blueprint_Network_Firewall_Services_Item `json:"services"`
		} `json:"firewall,omitempty"`
	} `json:"network,omitempty"`
	Openscap *struct {
		// Datastream Datastream to use for the scan. The datastream is the path to the SCAP datastream file to use for the scan. If the datastream parameter is not provided, a sensible default based on the selected distro will be chosen.
		Datastream *string `json:"datastream,omitempty"`

		// ProfileId The desired security profile ID.
		ProfileId string                        `json:"profile_id"`
		Tailoring *Blueprint_Openscap_Tailoring `json:"tailoring,omitempty"`
	} `json:"openscap,omitempty"`
	Registration *struct {
		Fdo    *Blueprint_Registration_Fdo `json:"fdo,omitempty"`
		Redhat *struct {
			// ActivationKey Subscription manager activation key to use during registration. A list of keys to use to redeem or apply specific subscriptions to the system.
			ActivationKey *string `json:"activation_key,omitempty"`
			Connector     *struct {
				// Enabled Enables rhc (Red Hat Connector) during boot.
				Enabled bool `json:"enabled"`
			} `json:"connector,omitempty"`
			Insights *struct {
				// Enabled Enables insights client during boot.
				Enabled bool `json:"enabled"`
			} `json:"insights,omitempty"`

			// Organization Subscription manager organization name to use during registration.
			Organization        *string `json:"organization,omitempty"`
			SubscriptionManager *struct {
				// AutoRegistration Enabled auto_registration plugin configuration.
				AutoRegistration bool `json:"auto_registration"`

				// Enabled Enables the subscription-manager DNF plugin.
				Enabled bool `json:"enabled"`

				// ProductPluginEnabled Enables the product-id DNF plugin.
				ProductPluginEnabled bool `json:"product_plugin_enabled"`

				// RepositoryManagement Enabled repository_management plugin configuration.
				RepositoryManagement bool `json:"repository_management"`
			} `json:"subscription_manager,omitempty"`
		} `json:"redhat,omitempty"`
	} `json:"registration,omitempty"`
	Storage *struct {
		// Minsize Minimum size of the storage device. When not set, the image size is acquired from image request.
		//
		// Size must be formatted as an integer followed by whitespace and then either a decimal unit (B, KB/kB, MB, GB, TB, PB, EB) or binary unit (KiB, MiB, GiB, TiB, PiB, EiB).
		Minsize string `json:"minsize"`

		// Partitions Partitions of the following types: plain (default), lvm, or btrfs.
		Partitions []interface{} `json:"partitions"`

		// Type Device partitioning type: gpt (default) or mbr.
		Type interface{} `json:"type"`
	} `json:"storage,omitempty"`
	Systemd *struct {
		// Disabled The disabled attribute is a list of strings that contains the systemd units to be disabled.
		Disabled *[]string `json:"disabled"`

		// Enabled The enabled attribute is a list of strings that contains the systemd units to be enabled.
		Enabled *[]string `json:"enabled"`

		// Masked The masked attribute is a list of strings that contains the systemd units to be masked.
		Masked *[]string `json:"masked"`
	} `json:"systemd,omitempty"`
	Timedate *struct {
		// NtpServers An optional list of strings containing NTP servers to use. If not provided the distribution defaults are used
		NtpServers *[]string `json:"ntp_servers,omitempty"`

		// Timezone System time zone. Defaults to UTC. To list available time zones run: timedatectl list-timezones
		Timezone string `json:"timezone"`
	} `json:"timedate,omitempty"`
}

// BlueprintDnfRepositories0 defines model for .
type BlueprintDnfRepositories0 = interface{}

// BlueprintDnfRepositories1 defines model for .
type BlueprintDnfRepositories1 = interface{}

// BlueprintDnfRepositories2 defines model for .
type BlueprintDnfRepositories2 = interface{}

// Blueprint_Dnf_Repositories_Item defines model for Blueprint.Dnf.Repositories.Item.
type Blueprint_Dnf_Repositories_Item struct {
	// BaseUrls Base URLs for the repository.
	BaseUrls *[]string `json:"base_urls,omitempty"`

	// Filename Repository filename to use for the repository configuration file. If not provided, the ID is used. Filename must be provided without the .repo extension.
	Filename *string `json:"filename,omitempty"`

	// GpgCheck Enable GPG check for the repository.
	GpgCheck *bool `json:"gpg_check,omitempty"`

	// GpgCheckRepo Enable GPG check for the repository metadata.
	GpgCheckRepo *bool `json:"gpg_check_repo,omitempty"`

	// GpgKeys GPG keys for the repository.
	//
	// The blueprint accepts both inline GPG keys and GPG key urls. If an inline GPG key is provided it will be saved to the /etc/pki/rpm-gpg directory and will be referenced accordingly in the repository configuration. GPG keys are not imported to the RPM database and will only be imported when first installing a package from the third-party repository.
	GpgKeys *[]string `json:"gpg_keys,omitempty"`

	// Id Repository ID. Required.
	Id string `json:"id"`

	// Metalink Metalink for the repository.
	Metalink *string `json:"metalink,omitempty"`

	// MirrorList Mirror list for the repository.
	MirrorList *string `json:"mirror_list,omitempty"`

	// ModuleHotfixes Enable module hotfixes for the repository.
	//
	// Adds module_hotfixes flag to all repo types so it can be used during osbuild. This enables users to disable modularity filtering on specific repositories.
	ModuleHotfixes *bool `json:"module_hotfixes,omitempty"`

	// Name Repository name.
	Name *string `json:"name,omitempty"`

	// Priority Repository priority.
	Priority *int `json:"priority,omitempty"`

	// SslVerify Enable SSL verification for the repository.
	SslVerify *bool `json:"ssl_verify,omitempty"`
	Usage     *struct {
		// Configure Configure the repository for dnf.
		//
		// A repository will be saved to the /etc/yum.repos.d directory in an image. An optional filename argument can be set, otherwise the repository will be saved using the the repository ID, i.e. /etc/yum.repos.d/<repo-id>.repo.
		Configure *bool `json:"configure,omitempty"`

		// Install Use the repository for image build.
		//
		// When this flag is set, it is possible to install third-party packages during the image build.
		Install *bool `json:"install,omitempty"`
	} `json:"usage,omitempty"`
	union json.RawMessage
}

// BlueprintFsnodes0 defines model for .
type BlueprintFsnodes0 = interface{}

// BlueprintFsnodes1 defines model for .
type BlueprintFsnodes1 = interface{}

// Blueprint_Fsnodes_Item defines model for blueprint.fsnodes.Item.
type Blueprint_Fsnodes_Item struct {
	union json.RawMessage
}

// BlueprintIgnitionEmbedded0 defines model for .
type BlueprintIgnitionEmbedded0 = interface{}

// BlueprintIgnitionEmbedded1 defines model for .
type BlueprintIgnitionEmbedded1 = interface{}

// Blueprint_Ignition_Embedded defines model for Blueprint.Ignition.Embedded.
type Blueprint_Ignition_Embedded struct {
	// Base64 Ignition data formatted in base64.
	Base64 *string `json:"base64,omitempty"`

	// Text Ignition data formatted in plain text.
	Text  *string `json:"text,omitempty"`
	union json.RawMessage
}

// BlueprintIgnition0 defines model for .
type BlueprintIgnition0 = interface{}

// BlueprintIgnition1 defines model for .
type BlueprintIgnition1 = interface{}

// Blueprint_Ignition defines model for Blueprint.Ignition.
type Blueprint_Ignition struct {
	Embedded *Blueprint_Ignition_Embedded `json:"embedded,omitempty"`

	// FirstbootUrl The URL to the Ignition configuration to be used by Ignition. This configuration is a URL to a remote Ignition configuration. The firstboot_url is used if the embedded configuration is not specified.
	//
	// Cannot be used with embedded_base64 or embedded_text.
	FirstbootUrl *string `json:"firstboot_url,omitempty"`
	union        json.RawMessage
}

// BlueprintInstallerAnacondaDisabledModules defines model for Blueprint.Installer.Anaconda.DisabledModules.
type BlueprintInstallerAnacondaDisabledModules string

// BlueprintInstallerAnacondaEnabledModules defines model for Blueprint.Installer.Anaconda.EnabledModules.
type BlueprintInstallerAnacondaEnabledModules string

// BlueprintInstallerAnacondaKickstart0 defines model for .
type BlueprintInstallerAnacondaKickstart0 = interface{}

// BlueprintInstallerAnacondaKickstart1 defines model for .
type BlueprintInstallerAnacondaKickstart1 = interface{}

// Blueprint_Installer_Anaconda_Kickstart defines model for Blueprint.Installer.Anaconda.Kickstart.
type Blueprint_Installer_Anaconda_Kickstart struct {
	// Base64 Kickstart file formatted in base64.
	Base64 *string `json:"base64,omitempty"`

	// Text Kickstart file formatted in plain text.
	Text  *string `json:"text,omitempty"`
	union json.RawMessage
}

// BlueprintNetworkFirewallServicesProtocol defines model for Blueprint.Network.Firewall.Services.Protocol.
type BlueprintNetworkFirewallServicesProtocol string

// BlueprintNetworkFirewallServices0 defines model for .
type BlueprintNetworkFirewallServices0 = interface{}

// BlueprintNetworkFirewallServices1 defines model for .
type BlueprintNetworkFirewallServices1 = interface{}

// BlueprintNetworkFirewallServices2 defines model for .
type BlueprintNetworkFirewallServices2 = interface{}

// Blueprint_Network_Firewall_Services_Item defines model for blueprint.network.firewall.services.Item.
type Blueprint_Network_Firewall_Services_Item struct {
	Enabled  *bool                                     `json:"enabled"`
	From     *int                                      `json:"from,omitempty"`
	Port     *int                                      `json:"port,omitempty"`
	Protocol *BlueprintNetworkFirewallServicesProtocol `json:"protocol,omitempty"`
	Service  *string                                   `json:"service,omitempty"`
	To       *int                                      `json:"to,omitempty"`
	union    json.RawMessage
}

// BlueprintOpenscapTailoring0 defines model for .
type BlueprintOpenscapTailoring0 struct {
	union json.RawMessage
}

// BlueprintOpenscapTailoring00 defines model for .
type BlueprintOpenscapTailoring00 = interface{}

// BlueprintOpenscapTailoring01 defines model for .
type BlueprintOpenscapTailoring01 = interface{}

// BlueprintOpenscapTailoring02 defines model for .
type BlueprintOpenscapTailoring02 = interface{}

// BlueprintOpenscapTailoring1 defines model for .
type BlueprintOpenscapTailoring1 = interface{}

// Blueprint_Openscap_Tailoring defines model for Blueprint.Openscap.Tailoring.
type Blueprint_Openscap_Tailoring struct {
	// JsonFilepath JSON filepath, must be used with json_profile_id and cannot be used with selected and unselected fields.
	JsonFilepath *string `json:"json_filepath,omitempty"`

	// JsonProfileId JSON profile ID, must be used with json_filepath and cannot be used with selected and unselected fields.
	JsonProfileId *string `json:"json_profile_id,omitempty"`

	// Selected Selected rules, cannot be used with json_profile_id and json_filepath.
	Selected *[]string `json:"selected,omitempty"`

	// Unselected Unselected rules, cannot be used with json_profile_id and json_filepath.
	Unselected *[]string `json:"unselected,omitempty"`
	union      json.RawMessage
}

// BlueprintRegistrationFdo0 defines model for .
type BlueprintRegistrationFdo0 = interface{}

// BlueprintRegistrationFdo1 defines model for .
type BlueprintRegistrationFdo1 = interface{}

// Blueprint_Registration_Fdo defines model for Blueprint.Registration.Fdo.
type Blueprint_Registration_Fdo struct {
	// DiMfgStringTypeMacIface Optional interface name for the MAC address.
	DiMfgStringTypeMacIface *string `json:"di_mfg_string_type_mac_iface,omitempty"`

	// DiunPubKeyHash FDO server public key hex-encoded hash. Cannot be used together with insecure option or root certs.
	DiunPubKeyHash *string `json:"diun_pub_key_hash,omitempty"`

	// DiunPubKeyInsecure FDO insecure option. When set, both hash or root certs must not be set.
	DiunPubKeyInsecure *bool `json:"diun_pub_key_insecure,omitempty"`

	// DiunPubKeyRootCerts FDO server public key root certificate path. Cannot be used together with insecure option or hash.
	DiunPubKeyRootCerts *string `json:"diun_pub_key_root_certs,omitempty"`

	// ManufacturingServerUrl FDO manufacturing server URL.
	ManufacturingServerUrl string `json:"manufacturing_server_url"`
	union                  json.RawMessage
}

// Error defines model for error.
type Error struct {
	Error *string `json:"error,omitempty"`
}

// ValidateBlueprintJSONRequestBody defines body for ValidateBlueprint for application/json ContentType.
type ValidateBlueprintJSONRequestBody = Blueprint

// AsBlueprintDnfRepositories0 returns the union data inside the Blueprint_Dnf_Repositories_Item as a BlueprintDnfRepositories0
func (t Blueprint_Dnf_Repositories_Item) AsBlueprintDnfRepositories0() (BlueprintDnfRepositories0, error) {
	var body BlueprintDnfRepositories0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBlueprintDnfRepositories0 overwrites any union data inside the Blueprint_Dnf_Repositories_Item as the provided BlueprintDnfRepositories0
func (t *Blueprint_Dnf_Repositories_Item) FromBlueprintDnfRepositories0(v BlueprintDnfRepositories0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBlueprintDnfRepositories0 performs a merge with any union data inside the Blueprint_Dnf_Repositories_Item, using the provided BlueprintDnfRepositories0
func (t *Blueprint_Dnf_Repositories_Item) MergeBlueprintDnfRepositories0(v BlueprintDnfRepositories0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBlueprintDnfRepositories1 returns the union data inside the Blueprint_Dnf_Repositories_Item as a BlueprintDnfRepositories1
func (t Blueprint_Dnf_Repositories_Item) AsBlueprintDnfRepositories1() (BlueprintDnfRepositories1, error) {
	var body BlueprintDnfRepositories1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBlueprintDnfRepositories1 overwrites any union data inside the Blueprint_Dnf_Repositories_Item as the provided BlueprintDnfRepositories1
func (t *Blueprint_Dnf_Repositories_Item) FromBlueprintDnfRepositories1(v BlueprintDnfRepositories1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBlueprintDnfRepositories1 performs a merge with any union data inside the Blueprint_Dnf_Repositories_Item, using the provided BlueprintDnfRepositories1
func (t *Blueprint_Dnf_Repositories_Item) MergeBlueprintDnfRepositories1(v BlueprintDnfRepositories1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBlueprintDnfRepositories2 returns the union data inside the Blueprint_Dnf_Repositories_Item as a BlueprintDnfRepositories2
func (t Blueprint_Dnf_Repositories_Item) AsBlueprintDnfRepositories2() (BlueprintDnfRepositories2, error) {
	var body BlueprintDnfRepositories2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBlueprintDnfRepositories2 overwrites any union data inside the Blueprint_Dnf_Repositories_Item as the provided BlueprintDnfRepositories2
func (t *Blueprint_Dnf_Repositories_Item) FromBlueprintDnfRepositories2(v BlueprintDnfRepositories2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBlueprintDnfRepositories2 performs a merge with any union data inside the Blueprint_Dnf_Repositories_Item, using the provided BlueprintDnfRepositories2
func (t *Blueprint_Dnf_Repositories_Item) MergeBlueprintDnfRepositories2(v BlueprintDnfRepositories2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Blueprint_Dnf_Repositories_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.BaseUrls != nil {
		object["base_urls"], err = json.Marshal(t.BaseUrls)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'base_urls': %w", err)
		}
	}

	if t.Filename != nil {
		object["filename"], err = json.Marshal(t.Filename)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'filename': %w", err)
		}
	}

	if t.GpgCheck != nil {
		object["gpg_check"], err = json.Marshal(t.GpgCheck)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'gpg_check': %w", err)
		}
	}

	if t.GpgCheckRepo != nil {
		object["gpg_check_repo"], err = json.Marshal(t.GpgCheckRepo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'gpg_check_repo': %w", err)
		}
	}

	if t.GpgKeys != nil {
		object["gpg_keys"], err = json.Marshal(t.GpgKeys)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'gpg_keys': %w", err)
		}
	}

	object["id"], err = json.Marshal(t.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	if t.Metalink != nil {
		object["metalink"], err = json.Marshal(t.Metalink)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'metalink': %w", err)
		}
	}

	if t.MirrorList != nil {
		object["mirror_list"], err = json.Marshal(t.MirrorList)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mirror_list': %w", err)
		}
	}

	if t.ModuleHotfixes != nil {
		object["module_hotfixes"], err = json.Marshal(t.ModuleHotfixes)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'module_hotfixes': %w", err)
		}
	}

	if t.Name != nil {
		object["name"], err = json.Marshal(t.Name)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'name': %w", err)
		}
	}

	if t.Priority != nil {
		object["priority"], err = json.Marshal(t.Priority)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'priority': %w", err)
		}
	}

	if t.SslVerify != nil {
		object["ssl_verify"], err = json.Marshal(t.SslVerify)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ssl_verify': %w", err)
		}
	}

	if t.Usage != nil {
		object["usage"], err = json.Marshal(t.Usage)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'usage': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *Blueprint_Dnf_Repositories_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["base_urls"]; found {
		err = json.Unmarshal(raw, &t.BaseUrls)
		if err != nil {
			return fmt.Errorf("error reading 'base_urls': %w", err)
		}
	}

	if raw, found := object["filename"]; found {
		err = json.Unmarshal(raw, &t.Filename)
		if err != nil {
			return fmt.Errorf("error reading 'filename': %w", err)
		}
	}

	if raw, found := object["gpg_check"]; found {
		err = json.Unmarshal(raw, &t.GpgCheck)
		if err != nil {
			return fmt.Errorf("error reading 'gpg_check': %w", err)
		}
	}

	if raw, found := object["gpg_check_repo"]; found {
		err = json.Unmarshal(raw, &t.GpgCheckRepo)
		if err != nil {
			return fmt.Errorf("error reading 'gpg_check_repo': %w", err)
		}
	}

	if raw, found := object["gpg_keys"]; found {
		err = json.Unmarshal(raw, &t.GpgKeys)
		if err != nil {
			return fmt.Errorf("error reading 'gpg_keys': %w", err)
		}
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &t.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
	}

	if raw, found := object["metalink"]; found {
		err = json.Unmarshal(raw, &t.Metalink)
		if err != nil {
			return fmt.Errorf("error reading 'metalink': %w", err)
		}
	}

	if raw, found := object["mirror_list"]; found {
		err = json.Unmarshal(raw, &t.MirrorList)
		if err != nil {
			return fmt.Errorf("error reading 'mirror_list': %w", err)
		}
	}

	if raw, found := object["module_hotfixes"]; found {
		err = json.Unmarshal(raw, &t.ModuleHotfixes)
		if err != nil {
			return fmt.Errorf("error reading 'module_hotfixes': %w", err)
		}
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &t.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
	}

	if raw, found := object["priority"]; found {
		err = json.Unmarshal(raw, &t.Priority)
		if err != nil {
			return fmt.Errorf("error reading 'priority': %w", err)
		}
	}

	if raw, found := object["ssl_verify"]; found {
		err = json.Unmarshal(raw, &t.SslVerify)
		if err != nil {
			return fmt.Errorf("error reading 'ssl_verify': %w", err)
		}
	}

	if raw, found := object["usage"]; found {
		err = json.Unmarshal(raw, &t.Usage)
		if err != nil {
			return fmt.Errorf("error reading 'usage': %w", err)
		}
	}

	return err
}

// AsBlueprintFsnodes0 returns the union data inside the Blueprint_Fsnodes_Item as a BlueprintFsnodes0
func (t Blueprint_Fsnodes_Item) AsBlueprintFsnodes0() (BlueprintFsnodes0, error) {
	var body BlueprintFsnodes0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBlueprintFsnodes0 overwrites any union data inside the Blueprint_Fsnodes_Item as the provided BlueprintFsnodes0
func (t *Blueprint_Fsnodes_Item) FromBlueprintFsnodes0(v BlueprintFsnodes0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBlueprintFsnodes0 performs a merge with any union data inside the Blueprint_Fsnodes_Item, using the provided BlueprintFsnodes0
func (t *Blueprint_Fsnodes_Item) MergeBlueprintFsnodes0(v BlueprintFsnodes0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBlueprintFsnodes1 returns the union data inside the Blueprint_Fsnodes_Item as a BlueprintFsnodes1
func (t Blueprint_Fsnodes_Item) AsBlueprintFsnodes1() (BlueprintFsnodes1, error) {
	var body BlueprintFsnodes1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBlueprintFsnodes1 overwrites any union data inside the Blueprint_Fsnodes_Item as the provided BlueprintFsnodes1
func (t *Blueprint_Fsnodes_Item) FromBlueprintFsnodes1(v BlueprintFsnodes1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBlueprintFsnodes1 performs a merge with any union data inside the Blueprint_Fsnodes_Item, using the provided BlueprintFsnodes1
func (t *Blueprint_Fsnodes_Item) MergeBlueprintFsnodes1(v BlueprintFsnodes1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Blueprint_Fsnodes_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Blueprint_Fsnodes_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBlueprintIgnitionEmbedded0 returns the union data inside the Blueprint_Ignition_Embedded as a BlueprintIgnitionEmbedded0
func (t Blueprint_Ignition_Embedded) AsBlueprintIgnitionEmbedded0() (BlueprintIgnitionEmbedded0, error) {
	var body BlueprintIgnitionEmbedded0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBlueprintIgnitionEmbedded0 overwrites any union data inside the Blueprint_Ignition_Embedded as the provided BlueprintIgnitionEmbedded0
func (t *Blueprint_Ignition_Embedded) FromBlueprintIgnitionEmbedded0(v BlueprintIgnitionEmbedded0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBlueprintIgnitionEmbedded0 performs a merge with any union data inside the Blueprint_Ignition_Embedded, using the provided BlueprintIgnitionEmbedded0
func (t *Blueprint_Ignition_Embedded) MergeBlueprintIgnitionEmbedded0(v BlueprintIgnitionEmbedded0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBlueprintIgnitionEmbedded1 returns the union data inside the Blueprint_Ignition_Embedded as a BlueprintIgnitionEmbedded1
func (t Blueprint_Ignition_Embedded) AsBlueprintIgnitionEmbedded1() (BlueprintIgnitionEmbedded1, error) {
	var body BlueprintIgnitionEmbedded1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBlueprintIgnitionEmbedded1 overwrites any union data inside the Blueprint_Ignition_Embedded as the provided BlueprintIgnitionEmbedded1
func (t *Blueprint_Ignition_Embedded) FromBlueprintIgnitionEmbedded1(v BlueprintIgnitionEmbedded1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBlueprintIgnitionEmbedded1 performs a merge with any union data inside the Blueprint_Ignition_Embedded, using the provided BlueprintIgnitionEmbedded1
func (t *Blueprint_Ignition_Embedded) MergeBlueprintIgnitionEmbedded1(v BlueprintIgnitionEmbedded1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Blueprint_Ignition_Embedded) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Base64 != nil {
		object["base64"], err = json.Marshal(t.Base64)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'base64': %w", err)
		}
	}

	if t.Text != nil {
		object["text"], err = json.Marshal(t.Text)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'text': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *Blueprint_Ignition_Embedded) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["base64"]; found {
		err = json.Unmarshal(raw, &t.Base64)
		if err != nil {
			return fmt.Errorf("error reading 'base64': %w", err)
		}
	}

	if raw, found := object["text"]; found {
		err = json.Unmarshal(raw, &t.Text)
		if err != nil {
			return fmt.Errorf("error reading 'text': %w", err)
		}
	}

	return err
}

// AsBlueprintIgnition0 returns the union data inside the Blueprint_Ignition as a BlueprintIgnition0
func (t Blueprint_Ignition) AsBlueprintIgnition0() (BlueprintIgnition0, error) {
	var body BlueprintIgnition0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBlueprintIgnition0 overwrites any union data inside the Blueprint_Ignition as the provided BlueprintIgnition0
func (t *Blueprint_Ignition) FromBlueprintIgnition0(v BlueprintIgnition0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBlueprintIgnition0 performs a merge with any union data inside the Blueprint_Ignition, using the provided BlueprintIgnition0
func (t *Blueprint_Ignition) MergeBlueprintIgnition0(v BlueprintIgnition0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBlueprintIgnition1 returns the union data inside the Blueprint_Ignition as a BlueprintIgnition1
func (t Blueprint_Ignition) AsBlueprintIgnition1() (BlueprintIgnition1, error) {
	var body BlueprintIgnition1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBlueprintIgnition1 overwrites any union data inside the Blueprint_Ignition as the provided BlueprintIgnition1
func (t *Blueprint_Ignition) FromBlueprintIgnition1(v BlueprintIgnition1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBlueprintIgnition1 performs a merge with any union data inside the Blueprint_Ignition, using the provided BlueprintIgnition1
func (t *Blueprint_Ignition) MergeBlueprintIgnition1(v BlueprintIgnition1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Blueprint_Ignition) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Embedded != nil {
		object["embedded"], err = json.Marshal(t.Embedded)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'embedded': %w", err)
		}
	}

	if t.FirstbootUrl != nil {
		object["firstboot_url"], err = json.Marshal(t.FirstbootUrl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'firstboot_url': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *Blueprint_Ignition) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["embedded"]; found {
		err = json.Unmarshal(raw, &t.Embedded)
		if err != nil {
			return fmt.Errorf("error reading 'embedded': %w", err)
		}
	}

	if raw, found := object["firstboot_url"]; found {
		err = json.Unmarshal(raw, &t.FirstbootUrl)
		if err != nil {
			return fmt.Errorf("error reading 'firstboot_url': %w", err)
		}
	}

	return err
}

// AsBlueprintInstallerAnacondaKickstart0 returns the union data inside the Blueprint_Installer_Anaconda_Kickstart as a BlueprintInstallerAnacondaKickstart0
func (t Blueprint_Installer_Anaconda_Kickstart) AsBlueprintInstallerAnacondaKickstart0() (BlueprintInstallerAnacondaKickstart0, error) {
	var body BlueprintInstallerAnacondaKickstart0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBlueprintInstallerAnacondaKickstart0 overwrites any union data inside the Blueprint_Installer_Anaconda_Kickstart as the provided BlueprintInstallerAnacondaKickstart0
func (t *Blueprint_Installer_Anaconda_Kickstart) FromBlueprintInstallerAnacondaKickstart0(v BlueprintInstallerAnacondaKickstart0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBlueprintInstallerAnacondaKickstart0 performs a merge with any union data inside the Blueprint_Installer_Anaconda_Kickstart, using the provided BlueprintInstallerAnacondaKickstart0
func (t *Blueprint_Installer_Anaconda_Kickstart) MergeBlueprintInstallerAnacondaKickstart0(v BlueprintInstallerAnacondaKickstart0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBlueprintInstallerAnacondaKickstart1 returns the union data inside the Blueprint_Installer_Anaconda_Kickstart as a BlueprintInstallerAnacondaKickstart1
func (t Blueprint_Installer_Anaconda_Kickstart) AsBlueprintInstallerAnacondaKickstart1() (BlueprintInstallerAnacondaKickstart1, error) {
	var body BlueprintInstallerAnacondaKickstart1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBlueprintInstallerAnacondaKickstart1 overwrites any union data inside the Blueprint_Installer_Anaconda_Kickstart as the provided BlueprintInstallerAnacondaKickstart1
func (t *Blueprint_Installer_Anaconda_Kickstart) FromBlueprintInstallerAnacondaKickstart1(v BlueprintInstallerAnacondaKickstart1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBlueprintInstallerAnacondaKickstart1 performs a merge with any union data inside the Blueprint_Installer_Anaconda_Kickstart, using the provided BlueprintInstallerAnacondaKickstart1
func (t *Blueprint_Installer_Anaconda_Kickstart) MergeBlueprintInstallerAnacondaKickstart1(v BlueprintInstallerAnacondaKickstart1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Blueprint_Installer_Anaconda_Kickstart) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Base64 != nil {
		object["base64"], err = json.Marshal(t.Base64)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'base64': %w", err)
		}
	}

	if t.Text != nil {
		object["text"], err = json.Marshal(t.Text)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'text': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *Blueprint_Installer_Anaconda_Kickstart) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["base64"]; found {
		err = json.Unmarshal(raw, &t.Base64)
		if err != nil {
			return fmt.Errorf("error reading 'base64': %w", err)
		}
	}

	if raw, found := object["text"]; found {
		err = json.Unmarshal(raw, &t.Text)
		if err != nil {
			return fmt.Errorf("error reading 'text': %w", err)
		}
	}

	return err
}

// AsBlueprintNetworkFirewallServices0 returns the union data inside the Blueprint_Network_Firewall_Services_Item as a BlueprintNetworkFirewallServices0
func (t Blueprint_Network_Firewall_Services_Item) AsBlueprintNetworkFirewallServices0() (BlueprintNetworkFirewallServices0, error) {
	var body BlueprintNetworkFirewallServices0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBlueprintNetworkFirewallServices0 overwrites any union data inside the Blueprint_Network_Firewall_Services_Item as the provided BlueprintNetworkFirewallServices0
func (t *Blueprint_Network_Firewall_Services_Item) FromBlueprintNetworkFirewallServices0(v BlueprintNetworkFirewallServices0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBlueprintNetworkFirewallServices0 performs a merge with any union data inside the Blueprint_Network_Firewall_Services_Item, using the provided BlueprintNetworkFirewallServices0
func (t *Blueprint_Network_Firewall_Services_Item) MergeBlueprintNetworkFirewallServices0(v BlueprintNetworkFirewallServices0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBlueprintNetworkFirewallServices1 returns the union data inside the Blueprint_Network_Firewall_Services_Item as a BlueprintNetworkFirewallServices1
func (t Blueprint_Network_Firewall_Services_Item) AsBlueprintNetworkFirewallServices1() (BlueprintNetworkFirewallServices1, error) {
	var body BlueprintNetworkFirewallServices1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBlueprintNetworkFirewallServices1 overwrites any union data inside the Blueprint_Network_Firewall_Services_Item as the provided BlueprintNetworkFirewallServices1
func (t *Blueprint_Network_Firewall_Services_Item) FromBlueprintNetworkFirewallServices1(v BlueprintNetworkFirewallServices1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBlueprintNetworkFirewallServices1 performs a merge with any union data inside the Blueprint_Network_Firewall_Services_Item, using the provided BlueprintNetworkFirewallServices1
func (t *Blueprint_Network_Firewall_Services_Item) MergeBlueprintNetworkFirewallServices1(v BlueprintNetworkFirewallServices1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBlueprintNetworkFirewallServices2 returns the union data inside the Blueprint_Network_Firewall_Services_Item as a BlueprintNetworkFirewallServices2
func (t Blueprint_Network_Firewall_Services_Item) AsBlueprintNetworkFirewallServices2() (BlueprintNetworkFirewallServices2, error) {
	var body BlueprintNetworkFirewallServices2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBlueprintNetworkFirewallServices2 overwrites any union data inside the Blueprint_Network_Firewall_Services_Item as the provided BlueprintNetworkFirewallServices2
func (t *Blueprint_Network_Firewall_Services_Item) FromBlueprintNetworkFirewallServices2(v BlueprintNetworkFirewallServices2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBlueprintNetworkFirewallServices2 performs a merge with any union data inside the Blueprint_Network_Firewall_Services_Item, using the provided BlueprintNetworkFirewallServices2
func (t *Blueprint_Network_Firewall_Services_Item) MergeBlueprintNetworkFirewallServices2(v BlueprintNetworkFirewallServices2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Blueprint_Network_Firewall_Services_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Enabled != nil {
		object["enabled"], err = json.Marshal(t.Enabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enabled': %w", err)
		}
	}

	if t.From != nil {
		object["from"], err = json.Marshal(t.From)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'from': %w", err)
		}
	}

	if t.Port != nil {
		object["port"], err = json.Marshal(t.Port)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'port': %w", err)
		}
	}

	if t.Protocol != nil {
		object["protocol"], err = json.Marshal(t.Protocol)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'protocol': %w", err)
		}
	}

	if t.Service != nil {
		object["service"], err = json.Marshal(t.Service)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'service': %w", err)
		}
	}

	if t.To != nil {
		object["to"], err = json.Marshal(t.To)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'to': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *Blueprint_Network_Firewall_Services_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["enabled"]; found {
		err = json.Unmarshal(raw, &t.Enabled)
		if err != nil {
			return fmt.Errorf("error reading 'enabled': %w", err)
		}
	}

	if raw, found := object["from"]; found {
		err = json.Unmarshal(raw, &t.From)
		if err != nil {
			return fmt.Errorf("error reading 'from': %w", err)
		}
	}

	if raw, found := object["port"]; found {
		err = json.Unmarshal(raw, &t.Port)
		if err != nil {
			return fmt.Errorf("error reading 'port': %w", err)
		}
	}

	if raw, found := object["protocol"]; found {
		err = json.Unmarshal(raw, &t.Protocol)
		if err != nil {
			return fmt.Errorf("error reading 'protocol': %w", err)
		}
	}

	if raw, found := object["service"]; found {
		err = json.Unmarshal(raw, &t.Service)
		if err != nil {
			return fmt.Errorf("error reading 'service': %w", err)
		}
	}

	if raw, found := object["to"]; found {
		err = json.Unmarshal(raw, &t.To)
		if err != nil {
			return fmt.Errorf("error reading 'to': %w", err)
		}
	}

	return err
}

// AsBlueprintOpenscapTailoring00 returns the union data inside the BlueprintOpenscapTailoring0 as a BlueprintOpenscapTailoring00
func (t BlueprintOpenscapTailoring0) AsBlueprintOpenscapTailoring00() (BlueprintOpenscapTailoring00, error) {
	var body BlueprintOpenscapTailoring00
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBlueprintOpenscapTailoring00 overwrites any union data inside the BlueprintOpenscapTailoring0 as the provided BlueprintOpenscapTailoring00
func (t *BlueprintOpenscapTailoring0) FromBlueprintOpenscapTailoring00(v BlueprintOpenscapTailoring00) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBlueprintOpenscapTailoring00 performs a merge with any union data inside the BlueprintOpenscapTailoring0, using the provided BlueprintOpenscapTailoring00
func (t *BlueprintOpenscapTailoring0) MergeBlueprintOpenscapTailoring00(v BlueprintOpenscapTailoring00) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBlueprintOpenscapTailoring01 returns the union data inside the BlueprintOpenscapTailoring0 as a BlueprintOpenscapTailoring01
func (t BlueprintOpenscapTailoring0) AsBlueprintOpenscapTailoring01() (BlueprintOpenscapTailoring01, error) {
	var body BlueprintOpenscapTailoring01
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBlueprintOpenscapTailoring01 overwrites any union data inside the BlueprintOpenscapTailoring0 as the provided BlueprintOpenscapTailoring01
func (t *BlueprintOpenscapTailoring0) FromBlueprintOpenscapTailoring01(v BlueprintOpenscapTailoring01) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBlueprintOpenscapTailoring01 performs a merge with any union data inside the BlueprintOpenscapTailoring0, using the provided BlueprintOpenscapTailoring01
func (t *BlueprintOpenscapTailoring0) MergeBlueprintOpenscapTailoring01(v BlueprintOpenscapTailoring01) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBlueprintOpenscapTailoring02 returns the union data inside the BlueprintOpenscapTailoring0 as a BlueprintOpenscapTailoring02
func (t BlueprintOpenscapTailoring0) AsBlueprintOpenscapTailoring02() (BlueprintOpenscapTailoring02, error) {
	var body BlueprintOpenscapTailoring02
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBlueprintOpenscapTailoring02 overwrites any union data inside the BlueprintOpenscapTailoring0 as the provided BlueprintOpenscapTailoring02
func (t *BlueprintOpenscapTailoring0) FromBlueprintOpenscapTailoring02(v BlueprintOpenscapTailoring02) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBlueprintOpenscapTailoring02 performs a merge with any union data inside the BlueprintOpenscapTailoring0, using the provided BlueprintOpenscapTailoring02
func (t *BlueprintOpenscapTailoring0) MergeBlueprintOpenscapTailoring02(v BlueprintOpenscapTailoring02) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BlueprintOpenscapTailoring0) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BlueprintOpenscapTailoring0) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBlueprintOpenscapTailoring0 returns the union data inside the Blueprint_Openscap_Tailoring as a BlueprintOpenscapTailoring0
func (t Blueprint_Openscap_Tailoring) AsBlueprintOpenscapTailoring0() (BlueprintOpenscapTailoring0, error) {
	var body BlueprintOpenscapTailoring0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBlueprintOpenscapTailoring0 overwrites any union data inside the Blueprint_Openscap_Tailoring as the provided BlueprintOpenscapTailoring0
func (t *Blueprint_Openscap_Tailoring) FromBlueprintOpenscapTailoring0(v BlueprintOpenscapTailoring0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBlueprintOpenscapTailoring0 performs a merge with any union data inside the Blueprint_Openscap_Tailoring, using the provided BlueprintOpenscapTailoring0
func (t *Blueprint_Openscap_Tailoring) MergeBlueprintOpenscapTailoring0(v BlueprintOpenscapTailoring0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBlueprintOpenscapTailoring1 returns the union data inside the Blueprint_Openscap_Tailoring as a BlueprintOpenscapTailoring1
func (t Blueprint_Openscap_Tailoring) AsBlueprintOpenscapTailoring1() (BlueprintOpenscapTailoring1, error) {
	var body BlueprintOpenscapTailoring1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBlueprintOpenscapTailoring1 overwrites any union data inside the Blueprint_Openscap_Tailoring as the provided BlueprintOpenscapTailoring1
func (t *Blueprint_Openscap_Tailoring) FromBlueprintOpenscapTailoring1(v BlueprintOpenscapTailoring1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBlueprintOpenscapTailoring1 performs a merge with any union data inside the Blueprint_Openscap_Tailoring, using the provided BlueprintOpenscapTailoring1
func (t *Blueprint_Openscap_Tailoring) MergeBlueprintOpenscapTailoring1(v BlueprintOpenscapTailoring1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Blueprint_Openscap_Tailoring) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.JsonFilepath != nil {
		object["json_filepath"], err = json.Marshal(t.JsonFilepath)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'json_filepath': %w", err)
		}
	}

	if t.JsonProfileId != nil {
		object["json_profile_id"], err = json.Marshal(t.JsonProfileId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'json_profile_id': %w", err)
		}
	}

	if t.Selected != nil {
		object["selected"], err = json.Marshal(t.Selected)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'selected': %w", err)
		}
	}

	if t.Unselected != nil {
		object["unselected"], err = json.Marshal(t.Unselected)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'unselected': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *Blueprint_Openscap_Tailoring) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["json_filepath"]; found {
		err = json.Unmarshal(raw, &t.JsonFilepath)
		if err != nil {
			return fmt.Errorf("error reading 'json_filepath': %w", err)
		}
	}

	if raw, found := object["json_profile_id"]; found {
		err = json.Unmarshal(raw, &t.JsonProfileId)
		if err != nil {
			return fmt.Errorf("error reading 'json_profile_id': %w", err)
		}
	}

	if raw, found := object["selected"]; found {
		err = json.Unmarshal(raw, &t.Selected)
		if err != nil {
			return fmt.Errorf("error reading 'selected': %w", err)
		}
	}

	if raw, found := object["unselected"]; found {
		err = json.Unmarshal(raw, &t.Unselected)
		if err != nil {
			return fmt.Errorf("error reading 'unselected': %w", err)
		}
	}

	return err
}

// AsBlueprintRegistrationFdo0 returns the union data inside the Blueprint_Registration_Fdo as a BlueprintRegistrationFdo0
func (t Blueprint_Registration_Fdo) AsBlueprintRegistrationFdo0() (BlueprintRegistrationFdo0, error) {
	var body BlueprintRegistrationFdo0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBlueprintRegistrationFdo0 overwrites any union data inside the Blueprint_Registration_Fdo as the provided BlueprintRegistrationFdo0
func (t *Blueprint_Registration_Fdo) FromBlueprintRegistrationFdo0(v BlueprintRegistrationFdo0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBlueprintRegistrationFdo0 performs a merge with any union data inside the Blueprint_Registration_Fdo, using the provided BlueprintRegistrationFdo0
func (t *Blueprint_Registration_Fdo) MergeBlueprintRegistrationFdo0(v BlueprintRegistrationFdo0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBlueprintRegistrationFdo1 returns the union data inside the Blueprint_Registration_Fdo as a BlueprintRegistrationFdo1
func (t Blueprint_Registration_Fdo) AsBlueprintRegistrationFdo1() (BlueprintRegistrationFdo1, error) {
	var body BlueprintRegistrationFdo1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBlueprintRegistrationFdo1 overwrites any union data inside the Blueprint_Registration_Fdo as the provided BlueprintRegistrationFdo1
func (t *Blueprint_Registration_Fdo) FromBlueprintRegistrationFdo1(v BlueprintRegistrationFdo1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBlueprintRegistrationFdo1 performs a merge with any union data inside the Blueprint_Registration_Fdo, using the provided BlueprintRegistrationFdo1
func (t *Blueprint_Registration_Fdo) MergeBlueprintRegistrationFdo1(v BlueprintRegistrationFdo1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Blueprint_Registration_Fdo) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.DiMfgStringTypeMacIface != nil {
		object["di_mfg_string_type_mac_iface"], err = json.Marshal(t.DiMfgStringTypeMacIface)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'di_mfg_string_type_mac_iface': %w", err)
		}
	}

	if t.DiunPubKeyHash != nil {
		object["diun_pub_key_hash"], err = json.Marshal(t.DiunPubKeyHash)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'diun_pub_key_hash': %w", err)
		}
	}

	if t.DiunPubKeyInsecure != nil {
		object["diun_pub_key_insecure"], err = json.Marshal(t.DiunPubKeyInsecure)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'diun_pub_key_insecure': %w", err)
		}
	}

	if t.DiunPubKeyRootCerts != nil {
		object["diun_pub_key_root_certs"], err = json.Marshal(t.DiunPubKeyRootCerts)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'diun_pub_key_root_certs': %w", err)
		}
	}

	object["manufacturing_server_url"], err = json.Marshal(t.ManufacturingServerUrl)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'manufacturing_server_url': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *Blueprint_Registration_Fdo) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["di_mfg_string_type_mac_iface"]; found {
		err = json.Unmarshal(raw, &t.DiMfgStringTypeMacIface)
		if err != nil {
			return fmt.Errorf("error reading 'di_mfg_string_type_mac_iface': %w", err)
		}
	}

	if raw, found := object["diun_pub_key_hash"]; found {
		err = json.Unmarshal(raw, &t.DiunPubKeyHash)
		if err != nil {
			return fmt.Errorf("error reading 'diun_pub_key_hash': %w", err)
		}
	}

	if raw, found := object["diun_pub_key_insecure"]; found {
		err = json.Unmarshal(raw, &t.DiunPubKeyInsecure)
		if err != nil {
			return fmt.Errorf("error reading 'diun_pub_key_insecure': %w", err)
		}
	}

	if raw, found := object["diun_pub_key_root_certs"]; found {
		err = json.Unmarshal(raw, &t.DiunPubKeyRootCerts)
		if err != nil {
			return fmt.Errorf("error reading 'diun_pub_key_root_certs': %w", err)
		}
	}

	if raw, found := object["manufacturing_server_url"]; found {
		err = json.Unmarshal(raw, &t.ManufacturingServerUrl)
		if err != nil {
			return fmt.Errorf("error reading 'manufacturing_server_url': %w", err)
		}
	}

	return err
}
