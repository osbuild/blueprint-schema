// Package blueprint provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package blueprint

import (
	"encoding/json"
	"fmt"

	"github.com/oapi-codegen/runtime"
)

// Defines values for AnacondaModules.
const (
	AnacondaModLocalization AnacondaModules = "org.fedoraproject.Anaconda.Modules.Localization"
	AnacondaModNetwork      AnacondaModules = "org.fedoraproject.Anaconda.Modules.Network"
	AnacondaModPayloads     AnacondaModules = "org.fedoraproject.Anaconda.Modules.Payloads"
	AnacondaModRuntime      AnacondaModules = "org.fedoraproject.Anaconda.Modules.Runtime"
	AnacondaModSecurity     AnacondaModules = "org.fedoraproject.Anaconda.Modules.Security"
	AnacondaModServices     AnacondaModules = "org.fedoraproject.Anaconda.Modules.Services"
	AnacondaModStorage      AnacondaModules = "org.fedoraproject.Anaconda.Modules.Storage"
	AnacondaModSubscription AnacondaModules = "org.fedoraproject.Anaconda.Modules.Subscription"
	AnacondaModTimezone     AnacondaModules = "org.fedoraproject.Anaconda.Modules.Timezone"
	AnacondaModUser         AnacondaModules = "org.fedoraproject.Anaconda.Modules.User"
)

// Defines values for FSNodeState.
const (
	Absent  FSNodeState = "absent"
	Present FSNodeState = "present"
)

// Defines values for FSNodeType.
const (
	Dir  FSNodeType = "dir"
	File FSNodeType = "file"
)

// Defines values for NetworkFirewallServicesProtocol.
const (
	Any NetworkFirewallServicesProtocol = "any"
	Tcp NetworkFirewallServicesProtocol = "tcp"
	Udp NetworkFirewallServicesProtocol = "udp"
)

// Blueprint Image Builder new blueprint schema.
//
// THIS IS WORK IN PROGRESS
type Blueprint struct {
	// Accounts Operating system user and group accounts to be created on the image.
	Accounts *Accounts `json:"accounts,omitempty"`

	// CACerts The CA certificates to be added to the image. The certificates
	// are added to the system-wide CA trust store. The certificates are added to
	// the /etc/pki/ca-trust/source/anchors/ directory and the update-ca-trust command
	// is run to update the system-wide CA trust store.
	CACerts []CACert `json:"cacerts"`

	// Containers Containers to be pulled during the image build and stored in the
	// image at the default local container storage location that is appropriate
	// for the image type, so that all supported container tools like podman and
	// cri-o will be able to work with it. The embedded containers are not started,
	// to do so you can create systemd unit files or quadlets with the files customization.
	Containers []Container `json:"containers"`

	// Description The description attribute is a string that can be a longer description
	// of the blueprint and is only used for display purposes.
	Description string `json:"description,omitempty"`

	// DNF DNF package managers details. When using virtual provides as the
	// package name the version glob should be *. And be aware that you will be unable
	// to freeze the blueprint. This is because the provides will expand into multiple
	// packages with their own names and versions.
	DNF *DNF `json:"dnf,omitempty"`

	// FIPS FIPS details, optional.
	FIPS *FIPS `json:"fips,omitempty"`

	// FSNodes File system nodes details.
	//
	// You can use the customization to create new files or to replace existing ones,
	// if not restricted by the policy specified below. If the target path is an existing
	// symlink to another file, the symlink will be replaced by the custom file.
	//
	// Please note that the parent directory of a specified file must exist. If it does
	// not exist, the image build will fail. One can ensure that the parent directory
	// exists by specifying "ensure_parents".
	//
	// In addition, the following files are not allowed to be created or replaced by
	// policy: /etc/fstab, /etc/shadow, /etc/passwd and /etc/group.
	//
	// Using the files customization comes with a high chance of creating an image that
	// doesn't boot. Use this feature only if you know what you are doing. Although the
	// files customization can be used to configure parts of the OS which can also be
	// configured by other blueprint customizations, this use is discouraged. If possible,
	// users should always default to using the specialized blueprint customizations.
	// Note that if you combine the files customizations with other customizations, the
	// other customizations may not work as expected or may be overridden by the files
	// customizations.
	//
	// You can create custom directories as well. The existence of a specified directory
	// is handled gracefully only if no explicit mode, user or group is specified. If any
	// of these customizations are specified and the directory already exists in the
	// image, the image build will fail. The intention is to prevent changing the
	// ownership or permissions of existing directories.
	FSNodes []FSNode `json:"fsnodes,omitempty"`

	// Hostname Hostname is an optional string that can be used to configure the
	// hostname of the final image.
	Hostname string `json:"hostname,omitempty"`

	// Ignition Provides Ignition configuration files to be used in edge-raw-image and
	// edge-simplified-installer images. Check the RHEL for Edge butane specification for
	// a description of the supported configuration options.
	//
	// The blueprint configuration can be done either by embedding an Ignition configuration
	// file into the image, or providing a provisioning URL that will be fetched at first boot.
	Ignition *Ignition `json:"ignition"`

	// Installer Extra customization for Anaconda installer (ISO) and Edge/IOT simplified
	// installer image types.
	Installer *Installer `json:"installer,omitempty"`

	// Kernel Custom Linux kernel details, optional.
	Kernel *Kernel `json:"kernel,omitempty"`

	// Locale An optional object that contains the following attributes to customize
	// the locale settings for the system. If the locale is not specified, the default
	// locale and keyboard settings are used: en_US.UTF-8 and us.
	Locale *Locale `json:"locale,omitempty"`

	// Name The name attribute is a string that contains the name of the blueprint.
	// It can contain spaces, but they may be converted to dash characters during build.
	// It should be short and descriptive.
	Name         string        `json:"name,omitempty"`
	Network      *Network      `json:"network,omitempty"`
	Openscap     *Openscap     `json:"openscap,omitempty"`
	Registration *Registration `json:"registration,omitempty"`
	Storage      *Storage      `json:"storage,omitempty"`
	Systemd      *Systemd      `json:"systemd,omitempty"`
	Timedate     *TimeDate     `json:"timedate,omitempty"`
}

// Ignition Provides Ignition configuration files to be used in edge-raw-image and
// edge-simplified-installer images. Check the RHEL for Edge butane specification for
// a description of the supported configuration options.
//
// The blueprint configuration can be done either by embedding an Ignition configuration
// file into the image, or providing a provisioning URL that will be fetched at first boot.
type Ignition struct {
	union json.RawMessage
}

// Accounts Operating system user and group accounts to be created on the image.
type Accounts struct {
	Groups []AccountsGroups `json:"groups"`
	Users  []AccountsUsers  `json:"users"`
}

// AccountsGroups Operating system group accounts to be created on the image.
type AccountsGroups struct {
	// GID The group ID (GID) of the group. Must be non-zero.
	GID int `json:"gid,omitempty"`

	// Name Group name. Accepted characters: lowercase letters, digits,
	// underscores, dollars, and hyphens. Name must not start with a hyphen. Maximum
	// length is 256 characters. The validation pattern is a relaxed version of
	// https://github.com/shadow-maint/shadow/blob/master/lib/chkname.c
	Name string `json:"name"`
}

// AccountsUsers Operating system user accounts to be created on the image.
type AccountsUsers struct {
	// Description A longer description of the account.
	Description string `json:"description,omitempty"`
	Expires     *Date  `json:"expires,omitempty"`

	// GID The primary group ID (GID) of the user. Value of zero (or ommited
	// value) means that the next available UID will be assigned.
	GID int `json:"gid,omitempty"`

	// Groups Additional groups that the user should be a member of.
	Groups []string `json:"groups,omitempty"`

	// Home The home directory of the user.
	Home string `json:"home,omitempty"`

	// Name Account name. Accepted characters: lowercase letters, digits,
	// underscores, dollars, and hyphens. Name must not start with a hyphen. Maximum
	// length is 256 characters. The validation pattern is a relaxed version of
	// https://github.com/shadow-maint/shadow/blob/master/lib/chkname.c
	Name string `json:"name"`

	// Password Password either in plain text or encrypted form. If the password
	// is not provided, the account will be locked and the user will not be able
	// to log in with a password. The password can be encrypted using the crypt(3)
	// function. The format of the encrypted password is $id$salt$hashed, where
	// $id is the algorithm used (1, 5, 6, or 2a).
	Password *string `json:"password,omitempty"`

	// Shell The shell of the user.
	Shell string `json:"shell,omitempty"`

	// SSHKeys SSH keys to be added to the account's authorized_keys file.
	SSHKeys []string `json:"ssh_keys,omitempty"`

	// UID The user ID (UID) of the user. Value of zero (or ommited value)
	// means that the next available UID will be assigned.
	UID int `json:"uid,omitempty"`
}

// AnacondaModules defines model for anaconda_modules.
type AnacondaModules string

// BoolDefaultTrue defines model for bool_default_true.
type BoolDefaultTrue = bool

// CACert The CA certificates to be added to the image.
type CACert struct {
	// PEM The PEM-encoded certificate.
	PEM *string `json:"pem,omitempty"`
}

// Container defines model for container.
type Container struct {
	// LocalStorage Whether to pull the container image from the host's local-storage.
	LocalStorage bool `json:"local_storage,omitempty"`

	// Name Container name is an optional string to set the name under which the container image will be saved in the image. If not specified name falls back to the same value as source.
	Name string `json:"name"`

	// Source Container image URL is a reference to a container image at a registry.
	Source string `json:"source"`

	// TLSVerify Verify TLS connection, default is true.
	TLSVerify bool `json:"tls_verify,omitempty"`
}

// Date defines model for date.
type Date = string

// DNF DNF package managers details. When using virtual provides as the
// package name the version glob should be *. And be aware that you will be unable
// to freeze the blueprint. This is because the provides will expand into multiple
// packages with their own names and versions.
type DNF struct {
	// Groups Groups to install, must match exactly. Groups describes groups
	// of packages to be installed into the image. Package groups are defined
	// in the repository metadata. Each group has a descriptive name used primarily
	// for display in user interfaces and an ID more commonly used in kickstart
	// files. Here, the ID is the expected way of listing a group. Groups have
	// three different ways of categorizing their packages: mandatory, default,
	// and optional. For the purposes of blueprints, only mandatory and default
	// packages will be installed. There is no mechanism for selecting optional
	// packages.
	Groups []string `json:"groups,omitempty"`

	// ImportKeys Additional file paths to the GPG keys to import. The files
	// must be present in the image. Does not support importing from URLs.
	ImportKeys []string `json:"import_keys,omitempty"`

	// Modules Modules to enable or disable
	Modules []string `json:"modules,omitempty"`

	// Packages Packages to install. Package name or NVRA is accepted as long
	// as DNF can resolve it. Examples: vim-enhanced, vim-enhanced-9.1.866-1
	// or vim-enhanced-9.1.866-1.fc41.x86_64. The packages can also be specified
	// as @group_name to install all packages in the group.
	Packages []string `json:"packages,omitempty"`

	// Repositories Third-party repositories are supported by the blueprint customizations.
	//
	// All fields reflect configuration values of dnf, see man dnf.conf(5) for more information.
	Repositories []DNFRepository `json:"repositories,omitempty"`
}

// DNFRepository defines model for dnf_repository.
type DNFRepository struct {
	// Filename Repository filename to use for the repository configuration file.
	// If not provided, the ID is used. Filename must be provided without the .repo
	// extension.
	Filename string `json:"filename,omitempty"`

	// GPGCheck Enable GPG check for the repository.
	GPGCheck bool `json:"gpg_check,omitempty"`

	// GPGCheckRepo Enable GPG check for the repository metadata.
	GPGCheckRepo bool `json:"gpg_check_repo,omitempty"`

	// GPGKeys GPG keys for the repository.
	//
	// The blueprint accepts both inline GPG keys and GPG key urls. If an inline GPG key is provided it will be saved to the /etc/pki/rpm-gpg directory and will be referenced accordingly in the repository configuration. GPG keys are not imported to the RPM database and will only be imported when first installing a package from the third-party repository.
	GPGKeys []string `json:"gpg_keys,omitempty"`

	// ID Repository ID. Required.
	ID string `json:"id"`

	// ModuleHotfixes Enable module hotfixes for the repository.
	//
	// Adds module_hotfixes flag to all repo types so it can be used during osbuild. This enables users to disable modularity filtering on specific repositories.
	ModuleHotfixes bool `json:"module_hotfixes,omitempty"`

	// Name Repository name.
	Name string `json:"name,omitempty"`

	// Priority Repository priority.
	Priority int `json:"priority,omitempty"`

	// Source Repository source.
	Source *DNFSource `json:"source,omitempty"`

	// SSLVerify Enable SSL verification for the repository.
	SSLVerify bool                `json:"ssl_verify,omitempty"`
	Usage     *DnfRepositoryUsage `json:"usage,omitempty"`
}

// DNFSource Repository source.
type DNFSource struct {
	union json.RawMessage
}

// DnfRepositoryUsage defines model for dnf_repository_usage.
type DnfRepositoryUsage = DNFRepoUsage

// DNFRepoUsage defines model for .
type DNFRepoUsage struct {
	// Configure Configure the repository for dnf on the created image.
	//
	// A repository will be saved as /etc/yum.repos.d/repository-id and enabled so when the image is
	// booted, the repository will be available for dnf. This is useful for third-party repositories
	// that are not part of the base image.
	Configure bool `json:"configure,omitempty"`

	// Install Use the repository for image build.
	//
	// When this flag is set, it is possible to install third-party packages during the image build.
	Install bool `json:"install,omitempty"`
}

// DnfSourceBaseUrls defines model for dnf_source_base_urls.
type DnfSourceBaseUrls = DNFSourceBaseURLs

// DNFSourceBaseURLs defines model for .
type DNFSourceBaseURLs struct {
	// Urls Base URLs for the repository.
	Urls []string `json:"urls,omitempty"`
}

// DnfSourceMetalink defines model for dnf_source_metalink.
type DnfSourceMetalink = DNFSourceMetalink

// DNFSourceMetalink defines model for .
type DNFSourceMetalink struct {
	// Urls Metalink for the repository.
	Urls string `json:"urls,omitempty"`
}

// DnfSourceMirrorlist defines model for dnf_source_mirrorlist.
type DnfSourceMirrorlist = DNFSourceMirrorlist

// DNFSourceMirrorlist defines model for .
type DNFSourceMirrorlist struct {
	// Urls Mirror list for the repository.
	Urls string `json:"urls,omitempty"`
}

// Error defines model for error.
type Error struct {
	Error *string `json:"error,omitempty"`
}

// FIPS FIPS details, optional.
type FIPS struct {
	// Enabled Enables the system FIPS mode (disabled by default). Currently
	// only edge-raw-image, edge-installer, edge-simplified-installer, edge-ami
	// and edge-vsphere images support this customization.
	Enabled bool `json:"enabled,omitempty"`
}

// FSNode defines model for fsnode.
type FSNode struct {
	// Contents Contents is the file system node contents. When not present,
	// an empty file is created.
	Contents *FSNodeContents `json:"contents,omitempty"`

	// EnsureParents EnsureParents is a boolean that determines if the parent directories
	// should be created if they do not exist.
	EnsureParents bool `json:"ensure_parents,omitempty"`

	// Group Group is the file system node group. Defaults to root.
	Group string `json:"group,omitempty"`

	// Mode Mode is the file system node permissions. Defaults to 0644 for
	// files and 0755 for directories.
	Mode int `json:"mode,omitempty"`

	// Path Path is the absolute path to the file or directory.
	Path string `json:"path"`

	// State State is the state of the file system node, one of: present, absent.
	State FSNodeState `json:"state,omitempty"`

	// Type Type is the type of the file system node, one of: file, dir.
	Type FSNodeType `json:"type,omitempty"`

	// User User is the file system node owner. Defaults to root.
	User string `json:"user,omitempty"`
}

// FSNodeContents Contents is the file system node contents. When not present,
// an empty file is created.
type FSNodeContents struct {
	union json.RawMessage
}

// FSNodeState State is the state of the file system node, one of: present, absent.
type FSNodeState string

// FSNodeType Type is the type of the file system node, one of: file, dir.
type FSNodeType string

// FsnodeContentsBase64 defines model for fsnode_contents_base64.
type FsnodeContentsBase64 = FSNodeContentsBase64

// FSNodeContentsBase64 defines model for .
type FSNodeContentsBase64 struct {
	// Base64 Base64-encoded file contents. Useful for binaries.
	Base64 string `json:"base64"`
}

// FsnodeContentsText defines model for fsnode_contents_text.
type FsnodeContentsText = FSNodeContentsText

// FSNodeContentsText defines model for .
type FSNodeContentsText struct {
	// Text Plain text file contents.
	Text string `json:"text"`
}

// IgnitionText defines model for ignition_text.
type IgnitionText struct {
	// Text Ignition data formatted in plain text.
	Text string `json:"text"`
}

// IgnitionUrl defines model for ignition_url.
type IgnitionUrl struct {
	// Url The URL to the Ignition configuration to be used by Ignition. This configuration
	// is a URL to a remote Ignition configuration.
	Url string `json:"url"`
}

// Installer Extra customization for Anaconda installer (ISO) and Edge/IOT simplified
// installer image types.
type Installer struct {
	// Anaconda Extra customizations for Anaconda installer (ISO) image types.
	//
	// Blueprint customizations that match the kickstart options (languages, keyboard,
	// timezone) will change the value in the kickstart file as well.
	Anaconda *InstallerAnaconda `json:"anaconda,omitempty"`

	// Coreos CoreOS installer configuration is required by the edge-simplified-installer
	// image. It allows to define the destination device for the installation.
	Coreos *InstallerCoreos `json:"coreos,omitempty"`
}

// InstallerAnaconda Extra customizations for Anaconda installer (ISO) image types.
//
// Blueprint customizations that match the kickstart options (languages, keyboard,
// timezone) will change the value in the kickstart file as well.
type InstallerAnaconda struct {
	// DisabledModules Anaconda modules to be disabled. The list of modules that
	// can be disabled is limited to the modules that are not required for the
	// installation. The list of modules that can be disabled is limited to the
	// modules that are not required for the installation.
	DisabledModules []AnacondaModules `json:"disabled_modules,omitempty"`

	// EnabledModules Anaconda modules to be enabled. The list of modules that
	// can be enabled is limited to the modules that are not required for the
	// installation. The list of modules that can be enabled is limited to the
	// modules that are not required for the installation.
	EnabledModules []AnacondaModules `json:"enabled_modules,omitempty"`

	// Kickstart Kickstart installer configuration.
	Kickstart string `json:"kickstart,omitempty"`

	// SudoNOPASSWD Sudo users with NOPASSWD option. Adds a snippet to the kickstart
	// file that, after installation, will create drop-in files in /etc/sudoers.d
	// to allow the specified users and groups to run sudo without a password (groups
	// must be prefixed with %).
	SudoNOPASSWD []string `json:"sudo_nopasswd,omitempty"`

	// Unattended Unattended installation Anaconda flag. When not set, Anaconda
	// installer will ask for user input.
	Unattended bool `json:"unattended,omitempty"`
}

// InstallerCoreos CoreOS installer configuration is required by the edge-simplified-installer
// image. It allows to define the destination device for the installation.
type InstallerCoreos = InstallerCoreOS

// InstallerCoreOS CoreOS installer configuration is required by the edge-simplified-installer
// image. It allows to define the destination device for the installation.
type InstallerCoreOS struct {
	// InstallationDevice Installation device for iot/edge simplified installer image types.
	InstallationDevice string `json:"installation_device,omitempty"`
}

// Kernel Custom Linux kernel details, optional.
type Kernel struct {
	// CmdlineAppend An optional string to append arguments to the bootloader kernel
	// command line. The list will be concatenated with spaces.
	CmdlineAppend []string `json:"cmdline_append,omitempty"`

	// Package Kernel package name to be installed.
	Package string `json:"package,omitempty"`
}

// Locale An optional object that contains the following attributes to customize
// the locale settings for the system. If the locale is not specified, the default
// locale and keyboard settings are used: en_US.UTF-8 and us.
type Locale struct {
	// Keyboards The keyboards attribute is a list of strings that contains
	// the keyboards to be installed on the image. To list available keyboards,
	// run: localectl list-keymaps
	Keyboards []string `json:"keyboards,omitempty"`

	// Languages The languages attribute is a list of strings that contains
	// the languages to be installed on the image. To list available languages,
	// run: localectl list-locales
	Languages []string `json:"languages,omitempty"`
}

// Network defines model for network.
type Network struct {
	Firewall *NetworkFirewall `json:"firewall,omitempty"`
}

// NetworkFirewall defines model for network_firewall.
type NetworkFirewall struct {
	// Services Services to enable or disable. The service can be defined via an assigned IANA name, port number or port range.
	//
	// Services are processed in order, when a service is disabled and then accidentally enabled via a port or a port range, the service will be enabled in the end.
	//
	// By default the firewall blocks all access, except for services that enable their ports explicitly such as the sshd.
	Services *[]NetworkFirewall_Services_Item `json:"services"`
}

// NetworkFirewallServicesProtocol defines model for NetworkFirewall.Services.Protocol.
type NetworkFirewallServicesProtocol string

// NetworkFirewallServices0 defines model for .
type NetworkFirewallServices0 = interface{}

// NetworkFirewallServices1 defines model for .
type NetworkFirewallServices1 = interface{}

// NetworkFirewallServices2 defines model for .
type NetworkFirewallServices2 = interface{}

// NetworkFirewall_Services_Item defines model for network_firewall.services.Item.
type NetworkFirewall_Services_Item struct {
	Enabled  *BoolDefaultTrue                 `json:"enabled"`
	From     *int                             `json:"from,omitempty"`
	Port     *int                             `json:"port,omitempty"`
	Protocol *NetworkFirewallServicesProtocol `json:"protocol,omitempty"`
	Service  *string                          `json:"service,omitempty"`
	To       *int                             `json:"to,omitempty"`
	union    json.RawMessage
}

// Openscap defines model for openscap.
type Openscap struct {
	// Datastream Datastream to use for the scan. The datastream is the path to the SCAP datastream file to use for the scan. If the datastream parameter is not provided, a sensible default based on the selected distro will be chosen.
	Datastream *string `json:"datastream,omitempty"`

	// ProfileId The desired security profile ID.
	ProfileId string             `json:"profile_id"`
	Tailoring *OpenscapTailoring `json:"tailoring,omitempty"`
}

// OpenscapTailoring defines model for openscap_tailoring.
type OpenscapTailoring struct {
	// JsonFilepath JSON filepath, must be used with json_profile_id and cannot be used with selected and unselected fields.
	JsonFilepath *string `json:"json_filepath,omitempty"`

	// JsonProfileId JSON profile ID, must be used with json_filepath and cannot be used with selected and unselected fields.
	JsonProfileId *string `json:"json_profile_id,omitempty"`

	// Selected Selected rules, cannot be used with json_profile_id and json_filepath.
	Selected *[]string `json:"selected,omitempty"`

	// Unselected Unselected rules, cannot be used with json_profile_id and json_filepath.
	Unselected *[]string `json:"unselected,omitempty"`
	union      json.RawMessage
}

// OpenscapTailoring0 defines model for .
type OpenscapTailoring0 struct {
	union json.RawMessage
}

// OpenscapTailoring00 defines model for .
type OpenscapTailoring00 = interface{}

// OpenscapTailoring01 defines model for .
type OpenscapTailoring01 = interface{}

// OpenscapTailoring02 defines model for .
type OpenscapTailoring02 = interface{}

// OpenscapTailoring1 defines model for .
type OpenscapTailoring1 = interface{}

// Registration defines model for registration.
type Registration struct {
	Fdo    *RegistrationFdo    `json:"fdo,omitempty"`
	Redhat *RegistrationRedhat `json:"redhat,omitempty"`
}

// RegistrationConnector defines model for registration_connector.
type RegistrationConnector struct {
	// Enabled Enables rhc (Red Hat Connector) during boot.
	Enabled bool `json:"enabled"`
}

// RegistrationFdo defines model for registration_fdo.
type RegistrationFdo struct {
	// DiMfgStringTypeMacIface Optional interface name for the MAC address.
	DiMfgStringTypeMacIface *string `json:"di_mfg_string_type_mac_iface,omitempty"`

	// DiunPubKeyHash FDO server public key hex-encoded hash. Cannot be used together with insecure option or root certs.
	DiunPubKeyHash *string `json:"diun_pub_key_hash,omitempty"`

	// DiunPubKeyInsecure FDO insecure option. When set, both hash or root certs must not be set.
	DiunPubKeyInsecure *bool `json:"diun_pub_key_insecure,omitempty"`

	// DiunPubKeyRootCerts FDO server public key root certificate path. Cannot be used together with insecure option or hash.
	DiunPubKeyRootCerts *string `json:"diun_pub_key_root_certs,omitempty"`

	// ManufacturingServerUrl FDO manufacturing server URL.
	ManufacturingServerUrl string `json:"manufacturing_server_url"`
	union                  json.RawMessage
}

// RegistrationFdo0 defines model for .
type RegistrationFdo0 = interface{}

// RegistrationFdo1 defines model for .
type RegistrationFdo1 = interface{}

// RegistrationInsights defines model for registration_insights.
type RegistrationInsights struct {
	// Enabled Enables insights client during boot.
	Enabled bool `json:"enabled"`
}

// RegistrationRedhat defines model for registration_redhat.
type RegistrationRedhat struct {
	// ActivationKey Subscription manager activation key to use during registration. A list of keys to use to redeem or apply specific subscriptions to the system.
	ActivationKey *string                `json:"activation_key,omitempty"`
	Connector     *RegistrationConnector `json:"connector,omitempty"`
	Insights      *RegistrationInsights  `json:"insights,omitempty"`

	// Organization Subscription manager organization name to use during registration.
	Organization        *string           `json:"organization,omitempty"`
	SubscriptionManager *RegistrationRhsm `json:"subscription_manager,omitempty"`
}

// RegistrationRhsm defines model for registration_rhsm.
type RegistrationRhsm struct {
	// AutoRegistration Enabled auto_registration plugin configuration.
	AutoRegistration bool `json:"auto_registration"`

	// Enabled Enables the subscription-manager DNF plugin.
	Enabled bool `json:"enabled"`

	// ProductPluginEnabled Enables the product-id DNF plugin.
	ProductPluginEnabled bool `json:"product_plugin_enabled"`

	// RepositoryManagement Enabled repository_management plugin configuration.
	RepositoryManagement bool `json:"repository_management"`
}

// Storage defines model for storage.
type Storage struct {
	// Minsize Minimum size of the storage device. When not set, the image size is acquired from image request.
	//
	// Size must be formatted as an integer followed by whitespace and then either a decimal unit (B, KB/kB, MB, GB, TB, PB, EB) or binary unit (KiB, MiB, GiB, TiB, PiB, EiB).
	Minsize string `json:"minsize"`

	// Partitions Partitions of the following types: plain (default), lvm, or btrfs.
	Partitions []StoragePartitions `json:"partitions"`

	// Type Device partitioning type: gpt (default) or mbr.
	Type interface{} `json:"type"`
}

// StorageLogicalVolumes defines model for storage_logical_volumes.
type StorageLogicalVolumes struct {
	// FsType File system type: ext4 (default), xfs, swap, or vfat.
	FsType *interface{} `json:"fs_type,omitempty"`

	// Label Label of the logical volume.
	Label *string `json:"label,omitempty"`

	// Minsize Minimum size of the logical volume.
	//
	// Size must be formatted as an integer followed by whitespace and then either a decimal unit (B, KB/kB, MB, GB, TB, PB, EB) or binary unit (KiB, MiB, GiB, TiB, PiB, EiB).
	Minsize *string `json:"minsize,omitempty"`

	// Mountpoint Mount point of the logical volume. Required except for swap fs_type.
	Mountpoint *string `json:"mountpoint,omitempty"`

	// Name Logical volume name. When not set, will be generated automatically.
	Name *string `json:"name,omitempty"`
}

// StoragePartitions defines model for storage_partitions.
type StoragePartitions = interface{}

// StorageSubvolumes defines model for storage_subvolumes.
type StorageSubvolumes struct {
	// Mountpoint Mount point of the subvolume. Required. Swap filesystem type is not supported on BTRFS volumes.
	Mountpoint *string `json:"mountpoint,omitempty"`

	// Name Subvolume name, must also define its parent volume.
	Name *string `json:"name,omitempty"`
}

// Systemd defines model for systemd.
type Systemd struct {
	// Disabled The disabled attribute is a list of strings that contains the systemd units to be disabled.
	Disabled *[]string `json:"disabled"`

	// Enabled The enabled attribute is a list of strings that contains the systemd units to be enabled.
	Enabled *[]string `json:"enabled"`

	// Masked The masked attribute is a list of strings that contains the systemd units to be masked.
	Masked *[]string `json:"masked"`
}

// TimeDate defines model for time_date.
type TimeDate struct {
	// NtpServers An optional list of strings containing NTP servers to use. If not provided the distribution defaults are used
	NtpServers *[]string `json:"ntp_servers,omitempty"`

	// Timezone System time zone. Defaults to UTC. To list available time zones run: timedatectl list-timezones
	Timezone string `json:"timezone"`
}

// ValidateBlueprintJSONRequestBody defines body for ValidateBlueprint for application/json ContentType.
type ValidateBlueprintJSONRequestBody = Blueprint

// AsIgnitionUrl returns the union data inside the Ignition as a IgnitionUrl
func (t Ignition) AsIgnitionUrl() (IgnitionUrl, error) {
	var body IgnitionUrl
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIgnitionUrl overwrites any union data inside the Ignition as the provided IgnitionUrl
func (t *Ignition) FromIgnitionUrl(v IgnitionUrl) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIgnitionUrl performs a merge with any union data inside the Ignition, using the provided IgnitionUrl
func (t *Ignition) MergeIgnitionUrl(v IgnitionUrl) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIgnitionText returns the union data inside the Ignition as a IgnitionText
func (t Ignition) AsIgnitionText() (IgnitionText, error) {
	var body IgnitionText
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIgnitionText overwrites any union data inside the Ignition as the provided IgnitionText
func (t *Ignition) FromIgnitionText(v IgnitionText) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIgnitionText performs a merge with any union data inside the Ignition, using the provided IgnitionText
func (t *Ignition) MergeIgnitionText(v IgnitionText) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Ignition) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Ignition) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDnfSourceBaseUrls returns the union data inside the DNFSource as a DnfSourceBaseUrls
func (t DNFSource) AsDnfSourceBaseUrls() (DnfSourceBaseUrls, error) {
	var body DnfSourceBaseUrls
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDnfSourceBaseUrls overwrites any union data inside the DNFSource as the provided DnfSourceBaseUrls
func (t *DNFSource) FromDnfSourceBaseUrls(v DnfSourceBaseUrls) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDnfSourceBaseUrls performs a merge with any union data inside the DNFSource, using the provided DnfSourceBaseUrls
func (t *DNFSource) MergeDnfSourceBaseUrls(v DnfSourceBaseUrls) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDnfSourceMetalink returns the union data inside the DNFSource as a DnfSourceMetalink
func (t DNFSource) AsDnfSourceMetalink() (DnfSourceMetalink, error) {
	var body DnfSourceMetalink
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDnfSourceMetalink overwrites any union data inside the DNFSource as the provided DnfSourceMetalink
func (t *DNFSource) FromDnfSourceMetalink(v DnfSourceMetalink) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDnfSourceMetalink performs a merge with any union data inside the DNFSource, using the provided DnfSourceMetalink
func (t *DNFSource) MergeDnfSourceMetalink(v DnfSourceMetalink) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDnfSourceMirrorlist returns the union data inside the DNFSource as a DnfSourceMirrorlist
func (t DNFSource) AsDnfSourceMirrorlist() (DnfSourceMirrorlist, error) {
	var body DnfSourceMirrorlist
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDnfSourceMirrorlist overwrites any union data inside the DNFSource as the provided DnfSourceMirrorlist
func (t *DNFSource) FromDnfSourceMirrorlist(v DnfSourceMirrorlist) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDnfSourceMirrorlist performs a merge with any union data inside the DNFSource, using the provided DnfSourceMirrorlist
func (t *DNFSource) MergeDnfSourceMirrorlist(v DnfSourceMirrorlist) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DNFSource) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DNFSource) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFsnodeContentsText returns the union data inside the FSNodeContents as a FsnodeContentsText
func (t FSNodeContents) AsFsnodeContentsText() (FsnodeContentsText, error) {
	var body FsnodeContentsText
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFsnodeContentsText overwrites any union data inside the FSNodeContents as the provided FsnodeContentsText
func (t *FSNodeContents) FromFsnodeContentsText(v FsnodeContentsText) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFsnodeContentsText performs a merge with any union data inside the FSNodeContents, using the provided FsnodeContentsText
func (t *FSNodeContents) MergeFsnodeContentsText(v FsnodeContentsText) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFsnodeContentsBase64 returns the union data inside the FSNodeContents as a FsnodeContentsBase64
func (t FSNodeContents) AsFsnodeContentsBase64() (FsnodeContentsBase64, error) {
	var body FsnodeContentsBase64
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFsnodeContentsBase64 overwrites any union data inside the FSNodeContents as the provided FsnodeContentsBase64
func (t *FSNodeContents) FromFsnodeContentsBase64(v FsnodeContentsBase64) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFsnodeContentsBase64 performs a merge with any union data inside the FSNodeContents, using the provided FsnodeContentsBase64
func (t *FSNodeContents) MergeFsnodeContentsBase64(v FsnodeContentsBase64) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t FSNodeContents) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FSNodeContents) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNetworkFirewallServices0 returns the union data inside the NetworkFirewall_Services_Item as a NetworkFirewallServices0
func (t NetworkFirewall_Services_Item) AsNetworkFirewallServices0() (NetworkFirewallServices0, error) {
	var body NetworkFirewallServices0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNetworkFirewallServices0 overwrites any union data inside the NetworkFirewall_Services_Item as the provided NetworkFirewallServices0
func (t *NetworkFirewall_Services_Item) FromNetworkFirewallServices0(v NetworkFirewallServices0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNetworkFirewallServices0 performs a merge with any union data inside the NetworkFirewall_Services_Item, using the provided NetworkFirewallServices0
func (t *NetworkFirewall_Services_Item) MergeNetworkFirewallServices0(v NetworkFirewallServices0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNetworkFirewallServices1 returns the union data inside the NetworkFirewall_Services_Item as a NetworkFirewallServices1
func (t NetworkFirewall_Services_Item) AsNetworkFirewallServices1() (NetworkFirewallServices1, error) {
	var body NetworkFirewallServices1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNetworkFirewallServices1 overwrites any union data inside the NetworkFirewall_Services_Item as the provided NetworkFirewallServices1
func (t *NetworkFirewall_Services_Item) FromNetworkFirewallServices1(v NetworkFirewallServices1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNetworkFirewallServices1 performs a merge with any union data inside the NetworkFirewall_Services_Item, using the provided NetworkFirewallServices1
func (t *NetworkFirewall_Services_Item) MergeNetworkFirewallServices1(v NetworkFirewallServices1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNetworkFirewallServices2 returns the union data inside the NetworkFirewall_Services_Item as a NetworkFirewallServices2
func (t NetworkFirewall_Services_Item) AsNetworkFirewallServices2() (NetworkFirewallServices2, error) {
	var body NetworkFirewallServices2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNetworkFirewallServices2 overwrites any union data inside the NetworkFirewall_Services_Item as the provided NetworkFirewallServices2
func (t *NetworkFirewall_Services_Item) FromNetworkFirewallServices2(v NetworkFirewallServices2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNetworkFirewallServices2 performs a merge with any union data inside the NetworkFirewall_Services_Item, using the provided NetworkFirewallServices2
func (t *NetworkFirewall_Services_Item) MergeNetworkFirewallServices2(v NetworkFirewallServices2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t NetworkFirewall_Services_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Enabled != nil {
		object["enabled"], err = json.Marshal(t.Enabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'enabled': %w", err)
		}
	}

	if t.From != nil {
		object["from"], err = json.Marshal(t.From)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'from': %w", err)
		}
	}

	if t.Port != nil {
		object["port"], err = json.Marshal(t.Port)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'port': %w", err)
		}
	}

	if t.Protocol != nil {
		object["protocol"], err = json.Marshal(t.Protocol)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'protocol': %w", err)
		}
	}

	if t.Service != nil {
		object["service"], err = json.Marshal(t.Service)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'service': %w", err)
		}
	}

	if t.To != nil {
		object["to"], err = json.Marshal(t.To)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'to': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *NetworkFirewall_Services_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["enabled"]; found {
		err = json.Unmarshal(raw, &t.Enabled)
		if err != nil {
			return fmt.Errorf("error reading 'enabled': %w", err)
		}
	}

	if raw, found := object["from"]; found {
		err = json.Unmarshal(raw, &t.From)
		if err != nil {
			return fmt.Errorf("error reading 'from': %w", err)
		}
	}

	if raw, found := object["port"]; found {
		err = json.Unmarshal(raw, &t.Port)
		if err != nil {
			return fmt.Errorf("error reading 'port': %w", err)
		}
	}

	if raw, found := object["protocol"]; found {
		err = json.Unmarshal(raw, &t.Protocol)
		if err != nil {
			return fmt.Errorf("error reading 'protocol': %w", err)
		}
	}

	if raw, found := object["service"]; found {
		err = json.Unmarshal(raw, &t.Service)
		if err != nil {
			return fmt.Errorf("error reading 'service': %w", err)
		}
	}

	if raw, found := object["to"]; found {
		err = json.Unmarshal(raw, &t.To)
		if err != nil {
			return fmt.Errorf("error reading 'to': %w", err)
		}
	}

	return err
}

// AsOpenscapTailoring0 returns the union data inside the OpenscapTailoring as a OpenscapTailoring0
func (t OpenscapTailoring) AsOpenscapTailoring0() (OpenscapTailoring0, error) {
	var body OpenscapTailoring0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOpenscapTailoring0 overwrites any union data inside the OpenscapTailoring as the provided OpenscapTailoring0
func (t *OpenscapTailoring) FromOpenscapTailoring0(v OpenscapTailoring0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOpenscapTailoring0 performs a merge with any union data inside the OpenscapTailoring, using the provided OpenscapTailoring0
func (t *OpenscapTailoring) MergeOpenscapTailoring0(v OpenscapTailoring0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOpenscapTailoring1 returns the union data inside the OpenscapTailoring as a OpenscapTailoring1
func (t OpenscapTailoring) AsOpenscapTailoring1() (OpenscapTailoring1, error) {
	var body OpenscapTailoring1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOpenscapTailoring1 overwrites any union data inside the OpenscapTailoring as the provided OpenscapTailoring1
func (t *OpenscapTailoring) FromOpenscapTailoring1(v OpenscapTailoring1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOpenscapTailoring1 performs a merge with any union data inside the OpenscapTailoring, using the provided OpenscapTailoring1
func (t *OpenscapTailoring) MergeOpenscapTailoring1(v OpenscapTailoring1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OpenscapTailoring) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.JsonFilepath != nil {
		object["json_filepath"], err = json.Marshal(t.JsonFilepath)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'json_filepath': %w", err)
		}
	}

	if t.JsonProfileId != nil {
		object["json_profile_id"], err = json.Marshal(t.JsonProfileId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'json_profile_id': %w", err)
		}
	}

	if t.Selected != nil {
		object["selected"], err = json.Marshal(t.Selected)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'selected': %w", err)
		}
	}

	if t.Unselected != nil {
		object["unselected"], err = json.Marshal(t.Unselected)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'unselected': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *OpenscapTailoring) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["json_filepath"]; found {
		err = json.Unmarshal(raw, &t.JsonFilepath)
		if err != nil {
			return fmt.Errorf("error reading 'json_filepath': %w", err)
		}
	}

	if raw, found := object["json_profile_id"]; found {
		err = json.Unmarshal(raw, &t.JsonProfileId)
		if err != nil {
			return fmt.Errorf("error reading 'json_profile_id': %w", err)
		}
	}

	if raw, found := object["selected"]; found {
		err = json.Unmarshal(raw, &t.Selected)
		if err != nil {
			return fmt.Errorf("error reading 'selected': %w", err)
		}
	}

	if raw, found := object["unselected"]; found {
		err = json.Unmarshal(raw, &t.Unselected)
		if err != nil {
			return fmt.Errorf("error reading 'unselected': %w", err)
		}
	}

	return err
}

// AsOpenscapTailoring00 returns the union data inside the OpenscapTailoring0 as a OpenscapTailoring00
func (t OpenscapTailoring0) AsOpenscapTailoring00() (OpenscapTailoring00, error) {
	var body OpenscapTailoring00
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOpenscapTailoring00 overwrites any union data inside the OpenscapTailoring0 as the provided OpenscapTailoring00
func (t *OpenscapTailoring0) FromOpenscapTailoring00(v OpenscapTailoring00) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOpenscapTailoring00 performs a merge with any union data inside the OpenscapTailoring0, using the provided OpenscapTailoring00
func (t *OpenscapTailoring0) MergeOpenscapTailoring00(v OpenscapTailoring00) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOpenscapTailoring01 returns the union data inside the OpenscapTailoring0 as a OpenscapTailoring01
func (t OpenscapTailoring0) AsOpenscapTailoring01() (OpenscapTailoring01, error) {
	var body OpenscapTailoring01
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOpenscapTailoring01 overwrites any union data inside the OpenscapTailoring0 as the provided OpenscapTailoring01
func (t *OpenscapTailoring0) FromOpenscapTailoring01(v OpenscapTailoring01) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOpenscapTailoring01 performs a merge with any union data inside the OpenscapTailoring0, using the provided OpenscapTailoring01
func (t *OpenscapTailoring0) MergeOpenscapTailoring01(v OpenscapTailoring01) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOpenscapTailoring02 returns the union data inside the OpenscapTailoring0 as a OpenscapTailoring02
func (t OpenscapTailoring0) AsOpenscapTailoring02() (OpenscapTailoring02, error) {
	var body OpenscapTailoring02
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOpenscapTailoring02 overwrites any union data inside the OpenscapTailoring0 as the provided OpenscapTailoring02
func (t *OpenscapTailoring0) FromOpenscapTailoring02(v OpenscapTailoring02) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOpenscapTailoring02 performs a merge with any union data inside the OpenscapTailoring0, using the provided OpenscapTailoring02
func (t *OpenscapTailoring0) MergeOpenscapTailoring02(v OpenscapTailoring02) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OpenscapTailoring0) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OpenscapTailoring0) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRegistrationFdo0 returns the union data inside the RegistrationFdo as a RegistrationFdo0
func (t RegistrationFdo) AsRegistrationFdo0() (RegistrationFdo0, error) {
	var body RegistrationFdo0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRegistrationFdo0 overwrites any union data inside the RegistrationFdo as the provided RegistrationFdo0
func (t *RegistrationFdo) FromRegistrationFdo0(v RegistrationFdo0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRegistrationFdo0 performs a merge with any union data inside the RegistrationFdo, using the provided RegistrationFdo0
func (t *RegistrationFdo) MergeRegistrationFdo0(v RegistrationFdo0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRegistrationFdo1 returns the union data inside the RegistrationFdo as a RegistrationFdo1
func (t RegistrationFdo) AsRegistrationFdo1() (RegistrationFdo1, error) {
	var body RegistrationFdo1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRegistrationFdo1 overwrites any union data inside the RegistrationFdo as the provided RegistrationFdo1
func (t *RegistrationFdo) FromRegistrationFdo1(v RegistrationFdo1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRegistrationFdo1 performs a merge with any union data inside the RegistrationFdo, using the provided RegistrationFdo1
func (t *RegistrationFdo) MergeRegistrationFdo1(v RegistrationFdo1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RegistrationFdo) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.DiMfgStringTypeMacIface != nil {
		object["di_mfg_string_type_mac_iface"], err = json.Marshal(t.DiMfgStringTypeMacIface)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'di_mfg_string_type_mac_iface': %w", err)
		}
	}

	if t.DiunPubKeyHash != nil {
		object["diun_pub_key_hash"], err = json.Marshal(t.DiunPubKeyHash)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'diun_pub_key_hash': %w", err)
		}
	}

	if t.DiunPubKeyInsecure != nil {
		object["diun_pub_key_insecure"], err = json.Marshal(t.DiunPubKeyInsecure)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'diun_pub_key_insecure': %w", err)
		}
	}

	if t.DiunPubKeyRootCerts != nil {
		object["diun_pub_key_root_certs"], err = json.Marshal(t.DiunPubKeyRootCerts)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'diun_pub_key_root_certs': %w", err)
		}
	}

	object["manufacturing_server_url"], err = json.Marshal(t.ManufacturingServerUrl)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'manufacturing_server_url': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *RegistrationFdo) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["di_mfg_string_type_mac_iface"]; found {
		err = json.Unmarshal(raw, &t.DiMfgStringTypeMacIface)
		if err != nil {
			return fmt.Errorf("error reading 'di_mfg_string_type_mac_iface': %w", err)
		}
	}

	if raw, found := object["diun_pub_key_hash"]; found {
		err = json.Unmarshal(raw, &t.DiunPubKeyHash)
		if err != nil {
			return fmt.Errorf("error reading 'diun_pub_key_hash': %w", err)
		}
	}

	if raw, found := object["diun_pub_key_insecure"]; found {
		err = json.Unmarshal(raw, &t.DiunPubKeyInsecure)
		if err != nil {
			return fmt.Errorf("error reading 'diun_pub_key_insecure': %w", err)
		}
	}

	if raw, found := object["diun_pub_key_root_certs"]; found {
		err = json.Unmarshal(raw, &t.DiunPubKeyRootCerts)
		if err != nil {
			return fmt.Errorf("error reading 'diun_pub_key_root_certs': %w", err)
		}
	}

	if raw, found := object["manufacturing_server_url"]; found {
		err = json.Unmarshal(raw, &t.ManufacturingServerUrl)
		if err != nil {
			return fmt.Errorf("error reading 'manufacturing_server_url': %w", err)
		}
	}

	return err
}
