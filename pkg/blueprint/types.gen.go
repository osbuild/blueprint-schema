// Package blueprint provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package blueprint

import (
	"encoding/json"

	"github.com/oapi-codegen/runtime"
)

// Defines values for NetworkProtocol.
const (
	Any NetworkProtocol = "any"
	TCP NetworkProtocol = "tcp"
	UDP NetworkProtocol = "udp"
)

// Defines values for AnacondaModules.
const (
	AnacondaModLocalization AnacondaModules = "org.fedoraproject.Anaconda.Modules.Localization"
	AnacondaModNetwork      AnacondaModules = "org.fedoraproject.Anaconda.Modules.Network"
	AnacondaModPayloads     AnacondaModules = "org.fedoraproject.Anaconda.Modules.Payloads"
	AnacondaModRuntime      AnacondaModules = "org.fedoraproject.Anaconda.Modules.Runtime"
	AnacondaModSecurity     AnacondaModules = "org.fedoraproject.Anaconda.Modules.Security"
	AnacondaModServices     AnacondaModules = "org.fedoraproject.Anaconda.Modules.Services"
	AnacondaModStorage      AnacondaModules = "org.fedoraproject.Anaconda.Modules.Storage"
	AnacondaModSubscription AnacondaModules = "org.fedoraproject.Anaconda.Modules.Subscription"
	AnacondaModTimezone     AnacondaModules = "org.fedoraproject.Anaconda.Modules.Timezone"
	AnacondaModUser         AnacondaModules = "org.fedoraproject.Anaconda.Modules.User"
)

// Defines values for FSNodeState.
const (
	Absent  FSNodeState = "absent"
	Present FSNodeState = "present"
)

// Defines values for FSNodeType.
const (
	Dir  FSNodeType = "dir"
	File FSNodeType = "file"
)

// Defines values for PartitionType.
const (
	PartTypeBTRFS PartitionType = "btrfs"
	PartTypeLVM   PartitionType = "lvm"
	PartTypePlain PartitionType = "plain"
)

// Defines values for FSType.
const (
	FSTypeExt4 FSType = "ext4"
	FSTypeSwap FSType = "swap"
	FSTypeVFAT FSType = "vfat"
	FSTypeXFS  FSType = "xfs"
)

// Defines values for StorageType.
const (
	StorageTypeGPT StorageType = "gpt"
	StorageTypeMBR StorageType = "mbr"
)

// NetworkProtocol The network protocol used for the connection. This can be either TCP, UDP, or any protocol.
type NetworkProtocol string

// FirewallEnabled Whether the firewall rule is enabled or not. Defaults to true.
type FirewallEnabled = bool

// Blueprint Image Builder new blueprint schema.
//
// THIS IS WORK IN PROGRESS
type Blueprint struct {
	// Accounts Operating system user and group accounts to be created on the image.
	Accounts *Accounts `json:"accounts,omitempty"`

	// CACerts The CA certificates to be added to the image. The certificates
	// are added to the system-wide CA trust store. The certificates are added to
	// the /etc/pki/ca-trust/source/anchors/ directory and the update-ca-trust command
	// is run to update the system-wide CA trust store.
	CACerts []CACert `json:"cacerts"`

	// Containers Containers to be pulled during the image build and stored in the
	// image at the default local container storage location that is appropriate
	// for the image type, so that all supported container tools like podman and
	// cri-o will be able to work with it. The embedded containers are not started,
	// to do so you can create systemd unit files or quadlets with the files customization.
	Containers []Container `json:"containers"`

	// Description The description attribute is a string that can be a longer description
	// of the blueprint and is only used for display purposes.
	Description string `json:"description,omitempty"`

	// DNF DNF package managers details. When using virtual provides as the
	// package name the version glob should be *. And be aware that you will be unable
	// to freeze the blueprint. This is because the provides will expand into multiple
	// packages with their own names and versions.
	DNF *DNF `json:"dnf,omitempty"`

	// FIPS FIPS details, optional.
	FIPS *FIPS `json:"fips,omitempty"`

	// FSNodes File system nodes details.
	//
	// You can use the customization to create new files or to replace existing ones,
	// if not restricted by the policy specified below. If the target path is an existing
	// symlink to another file, the symlink will be replaced by the custom file.
	//
	// Please note that the parent directory of a specified file must exist. If it does
	// not exist, the image build will fail. One can ensure that the parent directory
	// exists by specifying "ensure_parents".
	//
	// In addition, the following files are not allowed to be created or replaced by
	// policy: /etc/fstab, /etc/shadow, /etc/passwd and /etc/group.
	//
	// Using the files customization comes with a high chance of creating an image that
	// doesn't boot. Use this feature only if you know what you are doing. Although the
	// files customization can be used to configure parts of the OS which can also be
	// configured by other blueprint customizations, this use is discouraged. If possible,
	// users should always default to using the specialized blueprint customizations.
	// Note that if you combine the files customizations with other customizations, the
	// other customizations may not work as expected or may be overridden by the files
	// customizations.
	//
	// You can create custom directories as well. The existence of a specified directory
	// is handled gracefully only if no explicit mode, user or group is specified. If any
	// of these customizations are specified and the directory already exists in the
	// image, the image build will fail. The intention is to prevent changing the
	// ownership or permissions of existing directories.
	FSNodes []FSNode `json:"fsnodes,omitempty"`

	// Hostname Hostname is an optional string that can be used to configure the
	// hostname of the final image.
	Hostname string `json:"hostname,omitempty"`

	// Ignition Provides Ignition configuration files to be used in edge-raw-image and
	// edge-simplified-installer images. Check the RHEL for Edge butane specification for
	// a description of the supported configuration options.
	//
	// The blueprint configuration can be done either by embedding an Ignition configuration
	// file into the image, or providing a provisioning URL that will be fetched at first boot.
	Ignition *Ignition `json:"ignition"`

	// Installer Extra customization for Anaconda installer (ISO) and Edge/IOT simplified
	// installer image types.
	Installer *Installer `json:"installer,omitempty"`

	// Kernel Custom Linux kernel details, optional.
	Kernel *Kernel `json:"kernel,omitempty"`

	// Locale An optional object that contains the following attributes to customize
	// the locale settings for the system. If the locale is not specified, the default
	// locale and keyboard settings are used: en_US.UTF-8 and us.
	Locale *Locale `json:"locale,omitempty"`

	// Name The name attribute is a string that contains the name of the blueprint.
	// It can contain spaces, but they may be converted to dash characters during build.
	// It should be short and descriptive.
	Name string `json:"name,omitempty"`

	// Network Networking details including firewall configuration.
	Network *Network `json:"network,omitempty"`

	// OpenSCAP OpenSCAP policy to be applied on the operating system. Added in
	// RHEL 8.7 & RHEL 9.1. It is possible to either list policy rules (enable or
	// disable) or to provide a full policy file.
	OpenSCAP *OpenSCAP `json:"openscap,omitempty"`

	// Registration Registration details for various registration types, namely Red Hat
	// Subscription Manager.
	Registration *Registration `json:"registration,omitempty"`

	// Storage Disk partitioning details. Not available for installer-based images.
	//
	// General principles:
	//
	// 1. All sizes, whether for specific filesystems, partitions, logical volumes,
	// or the image itself, are treated as minimum requirements. This means the full
	// disk image size is always larger than the size of the sum of the partitions,
	// due to requirements for headers and metadata.
	//
	// 2. The partition that contains the root filesystem, whether this is a plain
	// formatted partition, an LVM Volume Group, or a Btrfs partition, is always last
	// in the partition table layout when it is automatically added. For Disk
	// customizations the user-defined order is respected.
	//
	// 3. In the case of raw partitioning (no LVM and no Btrfs), the partition
	// containing the root filesystem is grown to fill any left over space on the
	// partition table. Logical Volumes are not grown to fill the space in the Volume
	// Group since they are trivial to grow on a live system.
	Storage *Storage `json:"storage,omitempty"`

	// Systemd Systemd unit configuration.
	//
	// This section can be used to control which services are enabled at boot time.
	// Some image types already have services enabled or disabled in order for the image
	// to work correctly, and cannot be overridden. For example, ami image type requires
	// sshd, chronyd, and cloud-init services. Blueprint services do not replace these
	// services, but add them to the list of services already present in the templates,
	// if any.
	Systemd *Systemd `json:"systemd,omitempty"`

	// Timedate Time and date details allowing configuration of the timezone and
	// NTP servers. The timezone is set by default to UTC.
	Timedate *TimeDate `json:"timedate,omitempty"`
}

// Ignition Provides Ignition configuration files to be used in edge-raw-image and
// edge-simplified-installer images. Check the RHEL for Edge butane specification for
// a description of the supported configuration options.
//
// The blueprint configuration can be done either by embedding an Ignition configuration
// file into the image, or providing a provisioning URL that will be fetched at first boot.
type Ignition struct {
	union json.RawMessage
}

// Accounts Operating system user and group accounts to be created on the image.
type Accounts struct {
	Groups []AccountsGroups `json:"groups"`
	Users  []AccountsUsers  `json:"users"`
}

// AccountsGroups Operating system group accounts to be created on the image.
type AccountsGroups struct {
	// GID The group ID (GID) of the group. Must be non-zero.
	GID int `json:"gid,omitempty"`

	// Name Group name. Accepted characters: lowercase letters, digits,
	// underscores, dollars, and hyphens. Name must not start with a hyphen. Maximum
	// length is 256 characters. The validation pattern is a relaxed version of
	// https://github.com/shadow-maint/shadow/blob/master/lib/chkname.c
	Name string `json:"name"`
}

// AccountsUsers Operating system user accounts to be created on the image.
type AccountsUsers struct {
	// Description A longer description of the account.
	Description string `json:"description,omitempty"`
	Expires     *Date  `json:"expires,omitempty"`

	// GID The primary group ID (GID) of the user. Value of zero (or ommited
	// value) means that the next available UID will be assigned.
	GID int `json:"gid,omitempty"`

	// Groups Additional groups that the user should be a member of.
	Groups []string `json:"groups,omitempty"`

	// Home The home directory of the user.
	Home string `json:"home,omitempty"`

	// Name Account name. Accepted characters: lowercase letters, digits,
	// underscores, dollars, and hyphens. Name must not start with a hyphen. Maximum
	// length is 256 characters. The validation pattern is a relaxed version of
	// https://github.com/shadow-maint/shadow/blob/master/lib/chkname.c
	Name string `json:"name"`

	// Password Password either in plain text or encrypted form. If the password
	// is not provided, the account will be locked and the user will not be able
	// to log in with a password. The password can be encrypted using the crypt(3)
	// function. The format of the encrypted password is $id$salt$hashed, where
	// $id is the algorithm used (1, 5, 6, or 2a).
	Password *string `json:"password,omitempty"`

	// Shell The shell of the user.
	Shell string `json:"shell,omitempty"`

	// SSHKeys SSH keys to be added to the account's authorized_keys file.
	SSHKeys []string `json:"ssh_keys,omitempty"`

	// UID The user ID (UID) of the user. Value of zero (or ommited value)
	// means that the next available UID will be assigned.
	UID int `json:"uid,omitempty"`
}

// AnacondaModules defines model for anaconda_modules.
type AnacondaModules string

// CACert The CA certificates to be added to the image.
type CACert struct {
	// PEM The PEM-encoded certificate.
	PEM *string `json:"pem,omitempty"`
}

// Container defines model for container.
type Container struct {
	// LocalStorage Whether to pull the container image from the host's local-storage.
	LocalStorage bool `json:"local_storage,omitempty"`

	// Name Container name is an optional string to set the name under which the container image will be saved in the image. If not specified name falls back to the same value as source.
	Name string `json:"name"`

	// Source Container image URL is a reference to a container image at a registry.
	Source string `json:"source"`

	// TLSVerify Verify TLS connection, default is true.
	TLSVerify bool `json:"tls_verify,omitempty"`
}

// Date defines model for date.
type Date = string

// DNF DNF package managers details. When using virtual provides as the
// package name the version glob should be *. And be aware that you will be unable
// to freeze the blueprint. This is because the provides will expand into multiple
// packages with their own names and versions.
type DNF struct {
	// Groups Groups to install, must match exactly. Groups describes groups
	// of packages to be installed into the image. Package groups are defined
	// in the repository metadata. Each group has a descriptive name used primarily
	// for display in user interfaces and an ID more commonly used in kickstart
	// files. Here, the ID is the expected way of listing a group. Groups have
	// three different ways of categorizing their packages: mandatory, default,
	// and optional. For the purposes of blueprints, only mandatory and default
	// packages will be installed. There is no mechanism for selecting optional
	// packages.
	Groups []string `json:"groups,omitempty"`

	// ImportKeys Additional file paths to the GPG keys to import. The files
	// must be present in the image. Does not support importing from URLs.
	ImportKeys []string `json:"import_keys,omitempty"`

	// Modules Modules to enable or disable
	Modules []string `json:"modules,omitempty"`

	// Packages Packages to install. Package name or NVRA is accepted as long
	// as DNF can resolve it. Examples: vim-enhanced, vim-enhanced-9.1.866-1
	// or vim-enhanced-9.1.866-1.fc41.x86_64. The packages can also be specified
	// as @group_name to install all packages in the group.
	Packages []string `json:"packages,omitempty"`

	// Repositories Third-party repositories are supported by the blueprint customizations.
	//
	// All fields reflect configuration values of dnf, see man dnf.conf(5) for more information.
	Repositories []DNFRepository `json:"repositories,omitempty"`
}

// DNFRepository defines model for dnf_repository.
type DNFRepository struct {
	// Filename Repository filename to use for the repository configuration file.
	// If not provided, the ID is used. Filename must be provided without the .repo
	// extension.
	Filename string `json:"filename,omitempty"`

	// GPGCheck Enable GPG check for the repository.
	GPGCheck bool `json:"gpg_check,omitempty"`

	// GPGCheckRepo Enable GPG check for the repository metadata.
	GPGCheckRepo bool `json:"gpg_check_repo,omitempty"`

	// GPGKeys GPG keys for the repository.
	//
	// The blueprint accepts both inline GPG keys and GPG key urls. If an inline GPG key is provided it will be saved to the /etc/pki/rpm-gpg directory and will be referenced accordingly in the repository configuration. GPG keys are not imported to the RPM database and will only be imported when first installing a package from the third-party repository.
	GPGKeys []string `json:"gpg_keys,omitempty"`

	// ID Repository ID. Required.
	ID string `json:"id"`

	// ModuleHotfixes Enable module hotfixes for the repository.
	//
	// Adds module_hotfixes flag to all repo types so it can be used during osbuild. This enables users to disable modularity filtering on specific repositories.
	ModuleHotfixes bool `json:"module_hotfixes,omitempty"`

	// Name Repository name.
	Name string `json:"name,omitempty"`

	// Priority Repository priority.
	Priority int `json:"priority,omitempty"`

	// Source Repository source.
	Source *DNFSource `json:"source,omitempty"`

	// SSLVerify Enable SSL verification for the repository.
	SSLVerify bool                `json:"ssl_verify,omitempty"`
	Usage     *DnfRepositoryUsage `json:"usage,omitempty"`
}

// DNFSource Repository source.
type DNFSource struct {
	union json.RawMessage
}

// DnfRepositoryUsage defines model for dnf_repository_usage.
type DnfRepositoryUsage = DNFRepoUsage

// DNFRepoUsage defines model for .
type DNFRepoUsage struct {
	// Configure Configure the repository for dnf on the created image.
	//
	// A repository will be saved as /etc/yum.repos.d/repository-id and enabled so when the image is
	// booted, the repository will be available for dnf. This is useful for third-party repositories
	// that are not part of the base image.
	Configure bool `json:"configure,omitempty"`

	// Install Use the repository for image build.
	//
	// When this flag is set, it is possible to install third-party packages during the image build.
	Install bool `json:"install,omitempty"`
}

// DnfSourceBaseUrls defines model for dnf_source_base_urls.
type DnfSourceBaseUrls = DNFSourceBaseURLs

// DNFSourceBaseURLs defines model for .
type DNFSourceBaseURLs struct {
	// Urls Base URLs for the repository.
	Urls []string `json:"urls,omitempty"`
}

// DnfSourceMetalink defines model for dnf_source_metalink.
type DnfSourceMetalink = DNFSourceMetalink

// DNFSourceMetalink defines model for .
type DNFSourceMetalink struct {
	// Urls Metalink for the repository.
	Urls string `json:"urls,omitempty"`
}

// DnfSourceMirrorlist defines model for dnf_source_mirrorlist.
type DnfSourceMirrorlist = DNFSourceMirrorlist

// DNFSourceMirrorlist defines model for .
type DNFSourceMirrorlist struct {
	// Urls Mirror list for the repository.
	Urls string `json:"urls,omitempty"`
}

// Error defines model for error.
type Error struct {
	Error *string `json:"error,omitempty"`
}

// FIPS FIPS details, optional.
type FIPS struct {
	// Enabled Enables the system FIPS mode (disabled by default). Currently
	// only edge-raw-image, edge-installer, edge-simplified-installer, edge-ami
	// and edge-vsphere images support this customization.
	Enabled bool `json:"enabled,omitempty"`
}

// FirewallFromTo defines model for firewall_from_to.
type FirewallFromTo struct {
	// Protocol The network protocol used for the connection. This can be either TCP, UDP, or any protocol.
	Protocol NetworkProtocol `json:"protocol,omitempty"`

	// Enabled Whether the firewall rule is enabled or not. Defaults to true.
	Enabled FirewallEnabled `json:"enabled,omitempty"`

	// From The from port number, must be between 1 and 65535.
	From int `json:"from,omitempty"`

	// To The to port number, must be between 1 and 65535.
	To int `json:"to,omitempty"`
}

// FirewallPort defines model for firewall_port.
type FirewallPort struct {
	// Protocol The network protocol used for the connection. This can be either TCP, UDP, or any protocol.
	Protocol NetworkProtocol `json:"protocol,omitempty"`

	// Enabled Whether the firewall rule is enabled or not. Defaults to true.
	Enabled FirewallEnabled `json:"enabled,omitempty"`

	// Port The port number, must be between 1 and 65535.
	Port int `json:"port,omitempty"`
}

// FirewallService defines model for firewall_service.
type FirewallService struct {
	// Protocol The network protocol used for the connection. This can be either TCP, UDP, or any protocol.
	Protocol NetworkProtocol `json:"protocol,omitempty"`

	// Enabled Whether the firewall rule is enabled or not. Defaults to true.
	Enabled FirewallEnabled `json:"enabled,omitempty"`

	// Service The name of the IANA service name. This is the name of the service as defined in
	// the /etc/services file.
	Service string `json:"service,omitempty"`
}

// FSNode defines model for fsnode.
type FSNode struct {
	// Contents Contents is the file system node contents. When not present,
	// an empty file is created.
	Contents *FSNodeContents `json:"contents,omitempty"`

	// EnsureParents EnsureParents is a boolean that determines if the parent directories
	// should be created if they do not exist.
	EnsureParents bool `json:"ensure_parents,omitempty"`

	// Group Group is the file system node group. Defaults to root.
	Group string `json:"group,omitempty"`

	// Mode Mode is the file system node permissions. Defaults to 0644 for
	// files and 0755 for directories.
	Mode int `json:"mode,omitempty"`

	// Path Path is the absolute path to the file or directory.
	Path string `json:"path"`

	// State State is the state of the file system node, one of: present, absent.
	State FSNodeState `json:"state,omitempty"`

	// Type Type is the type of the file system node, one of: file, dir.
	Type FSNodeType `json:"type,omitempty"`

	// User User is the file system node owner. Defaults to root.
	User string `json:"user,omitempty"`
}

// FSNodeContents Contents is the file system node contents. When not present,
// an empty file is created.
type FSNodeContents struct {
	union json.RawMessage
}

// FSNodeState State is the state of the file system node, one of: present, absent.
type FSNodeState string

// FSNodeType Type is the type of the file system node, one of: file, dir.
type FSNodeType string

// FsnodeContentsBase64 defines model for fsnode_contents_base64.
type FsnodeContentsBase64 = FSNodeContentsBase64

// FSNodeContentsBase64 defines model for .
type FSNodeContentsBase64 struct {
	// Base64 Base64-encoded file contents. Useful for binaries.
	Base64 string `json:"base64"`
}

// FsnodeContentsText defines model for fsnode_contents_text.
type FsnodeContentsText = FSNodeContentsText

// FSNodeContentsText defines model for .
type FSNodeContentsText struct {
	// Text Plain text file contents.
	Text string `json:"text"`
}

// IgnitionText defines model for ignition_text.
type IgnitionText struct {
	// Text Ignition data formatted in plain text.
	Text string `json:"text"`
}

// IgnitionUrl defines model for ignition_url.
type IgnitionUrl struct {
	// Url The URL to the Ignition configuration to be used by Ignition. This configuration
	// is a URL to a remote Ignition configuration.
	Url string `json:"url"`
}

// Installer Extra customization for Anaconda installer (ISO) and Edge/IOT simplified
// installer image types.
type Installer struct {
	// Anaconda Extra customizations for Anaconda installer (ISO) image types.
	//
	// Blueprint customizations that match the kickstart options (languages, keyboard,
	// timezone) will change the value in the kickstart file as well.
	Anaconda *InstallerAnaconda `json:"anaconda,omitempty"`

	// Coreos CoreOS installer configuration is required by the edge-simplified-installer
	// image. It allows to define the destination device for the installation.
	Coreos *InstallerCoreos `json:"coreos,omitempty"`
}

// InstallerAnaconda Extra customizations for Anaconda installer (ISO) image types.
//
// Blueprint customizations that match the kickstart options (languages, keyboard,
// timezone) will change the value in the kickstart file as well.
type InstallerAnaconda struct {
	// DisabledModules Anaconda modules to be disabled. The list of modules that
	// can be disabled is limited to the modules that are not required for the
	// installation. The list of modules that can be disabled is limited to the
	// modules that are not required for the installation.
	DisabledModules []AnacondaModules `json:"disabled_modules,omitempty"`

	// EnabledModules Anaconda modules to be enabled. The list of modules that
	// can be enabled is limited to the modules that are not required for the
	// installation. The list of modules that can be enabled is limited to the
	// modules that are not required for the installation.
	EnabledModules []AnacondaModules `json:"enabled_modules,omitempty"`

	// Kickstart Kickstart installer configuration.
	Kickstart string `json:"kickstart,omitempty"`

	// SudoNOPASSWD Sudo users with NOPASSWD option. Adds a snippet to the kickstart
	// file that, after installation, will create drop-in files in /etc/sudoers.d
	// to allow the specified users and groups to run sudo without a password (groups
	// must be prefixed with %).
	SudoNOPASSWD []string `json:"sudo_nopasswd,omitempty"`

	// Unattended Unattended installation Anaconda flag. When not set, Anaconda
	// installer will ask for user input.
	Unattended bool `json:"unattended,omitempty"`
}

// InstallerCoreos CoreOS installer configuration is required by the edge-simplified-installer
// image. It allows to define the destination device for the installation.
type InstallerCoreos = InstallerCoreOS

// InstallerCoreOS CoreOS installer configuration is required by the edge-simplified-installer
// image. It allows to define the destination device for the installation.
type InstallerCoreOS struct {
	// InstallationDevice Installation device for iot/edge simplified installer image types.
	InstallationDevice string `json:"installation_device,omitempty"`
}

// Kernel Custom Linux kernel details, optional.
type Kernel struct {
	// CmdlineAppend An optional string to append arguments to the bootloader kernel
	// command line. The list will be concatenated with spaces.
	CmdlineAppend []string `json:"cmdline_append,omitempty"`

	// Package Kernel package name to be installed.
	Package string `json:"package,omitempty"`
}

// Locale An optional object that contains the following attributes to customize
// the locale settings for the system. If the locale is not specified, the default
// locale and keyboard settings are used: en_US.UTF-8 and us.
type Locale struct {
	// Keyboards The keyboards attribute is a list of strings that contains
	// the keyboards to be installed on the image. To list available keyboards,
	// run: localectl list-keymaps
	Keyboards []string `json:"keyboards,omitempty"`

	// Languages The languages attribute is a list of strings that contains
	// the languages to be installed on the image. To list available languages,
	// run: localectl list-locales
	Languages []string `json:"languages,omitempty"`
}

// Network Networking details including firewall configuration.
type Network struct {
	// Firewall Firewall details - package firewalld must be installed in the image.
	Firewall *NetworkFirewall `json:"firewall,omitempty"`
}

// NetworkFirewall Firewall details - package firewalld must be installed in the image.
type NetworkFirewall struct {
	// Services Services to enable or disable. The service can be defined via an assigned
	// IANA name, port number or port range.
	//
	// Services are processed in order, when a service is disabled and then accidentally
	// enabled via a port or a port range, the service will be enabled in the end.
	//
	// By default the firewall blocks all access, except for services that enable their
	// ports explicitly such as the sshd.
	Services []NetworkService `json:"services,omitempty"`
}

// NetworkService defines model for .
type NetworkService struct {
	union json.RawMessage
}

// OpenSCAP OpenSCAP policy to be applied on the operating system. Added in
// RHEL 8.7 & RHEL 9.1. It is possible to either list policy rules (enable or
// disable) or to provide a full policy file.
type OpenSCAP struct {
	// Datastream Datastream to use for the scan. The datastream is the path to
	// the SCAP datastream file to use for the scan. If the datastream parameter
	// is not provided, a sensible default based on the selected distro will be
	// chosen.
	Datastream string `json:"datastream,omitempty"`

	// ProfileID The desired security profile ID.
	ProfileID string `json:"profile_id"`

	// Tailoring An optional OpenSCAP tailoring information. Can be done via profile
	// selection or tailoring JSON file.
	//
	// In case of profile selection, a tailoring file with a new tailoring profile
	// ID is created and saved to the image. The new tailoring profile ID is
	// created by appending the _osbuild_tailoring suffix to the base profile.
	// For example, given tailoring options for the cis profile, tailoring profile
	// xccdf_org.ssgproject.content_profile_cis_osbuild_tailoring will be created.
	// The default namespace of the rules is org.ssgproject.content, so the prefix
	// may be omitted for rules under this namespace, i.e.
	// org.ssgproject.content_grub2_password and grub2_password are functionally
	// equivalent. The generated tailoring file is saved to the image as
	// /usr/share/xml/osbuild-oscap-tailoring/tailoring.xml or, for newer releases,
	// in the /oscap_data directory, this is the location used for other OpenSCAP
	// related artifacts.
	//
	// It is also possible to use JSON tailoring. In that case, custom JSON file
	// must be provided using the blueprint and used in json_filepath field
	// alongside with json_profile_id field. The generated XML tailoring file
	// is saved to the image as /oscap_data/tailoring.xml.
	Tailoring *OpenSCAPTailoring `json:"tailoring,omitempty"`
}

// OpenSCAPTailoring An optional OpenSCAP tailoring information. Can be done via profile
// selection or tailoring JSON file.
//
// In case of profile selection, a tailoring file with a new tailoring profile
// ID is created and saved to the image. The new tailoring profile ID is
// created by appending the _osbuild_tailoring suffix to the base profile.
// For example, given tailoring options for the cis profile, tailoring profile
// xccdf_org.ssgproject.content_profile_cis_osbuild_tailoring will be created.
// The default namespace of the rules is org.ssgproject.content, so the prefix
// may be omitted for rules under this namespace, i.e.
// org.ssgproject.content_grub2_password and grub2_password are functionally
// equivalent. The generated tailoring file is saved to the image as
// /usr/share/xml/osbuild-oscap-tailoring/tailoring.xml or, for newer releases,
// in the /oscap_data directory, this is the location used for other OpenSCAP
// related artifacts.
//
// It is also possible to use JSON tailoring. In that case, custom JSON file
// must be provided using the blueprint and used in json_filepath field
// alongside with json_profile_id field. The generated XML tailoring file
// is saved to the image as /oscap_data/tailoring.xml.
type OpenSCAPTailoring struct {
	union json.RawMessage
}

// PartitionBtrfs defines model for partition_btrfs.
type PartitionBtrfs = PartitionBTRFS

// PartitionBTRFS defines model for .
type PartitionBTRFS struct {
	// Minsize Minimum size of the volume.
	//
	// Size must be formatted as an integer followed by whitespace and then either a
	// decimal unit (B, KB/kB, MB, GB, TB, PB, EB) or binary unit (KiB, MiB, GiB,
	// TiB, PiB, EiB).
	Minsize StorageMinsize `json:"minsize,omitempty"`

	// Subvolumes BTRFS subvolumes to create.
	//
	// Relevant for partition types: btrfs.
	Subvolumes []PartitionSubvolumes `json:"subvolumes,omitempty"`

	// Type Partition type: plain (default), lvm, or btrfs.
	Type PartitionType `json:"type"`
}

// PartitionLv defines model for partition_lv.
type PartitionLv = PartitionLV

// PartitionLV defines model for .
type PartitionLV struct {
	// FSType File system type: ext4 (default), xfs, swap, or vfat.
	//
	// Relevant for partition types: plain.
	FSType FSType `json:"fs_type,omitempty"`

	// Label Optional label of the partition.
	Label string `json:"label,omitempty"`

	// Minsize Minimum size of the volume.
	//
	// Size must be formatted as an integer followed by whitespace and then either a
	// decimal unit (B, KB/kB, MB, GB, TB, PB, EB) or binary unit (KiB, MiB, GiB,
	// TiB, PiB, EiB).
	Minsize StorageMinsize `json:"minsize,omitempty"`

	// Mountpoint Mount point of the partition. Must start with a slash.
	Mountpoint StorageMountpoint `json:"mountpoint,omitempty"`

	// Name Logical volume name. When not set, will be generated automatically.
	Name string `json:"name,omitempty"`
}

// PartitionLvm defines model for partition_lvm.
type PartitionLvm = PartitionLVM

// PartitionLVM defines model for .
type PartitionLVM struct {
	// FSType File system type: ext4 (default), xfs, swap, or vfat.
	//
	// Relevant for partition types: plain.
	FSType FSType `json:"fs_type,omitempty"`

	// LogicalVolumes LVM logical volumes to create within the volume group.
	//
	// Relevant for partition types: lvm.
	LogicalVolumes []PartitionLv `json:"logical_volumes,omitempty"`

	// Type Partition type: plain (default), lvm, or btrfs.
	Type PartitionType `json:"type"`
}

// PartitionPlain defines model for partition_plain.
type PartitionPlain struct {
	// FSType File system type: ext4 (default), xfs, swap, or vfat.
	//
	// Relevant for partition types: plain.
	FSType FSType `json:"fs_type,omitempty"`

	// Label Optional label of the partition.
	Label string `json:"label,omitempty"`

	// Minsize Minimum size of the volume.
	//
	// Size must be formatted as an integer followed by whitespace and then either a
	// decimal unit (B, KB/kB, MB, GB, TB, PB, EB) or binary unit (KiB, MiB, GiB,
	// TiB, PiB, EiB).
	Minsize StorageMinsize `json:"minsize,omitempty"`

	// Mountpoint Mount point of the partition. Must start with a slash.
	Mountpoint StorageMountpoint `json:"mountpoint,omitempty"`

	// Type Partition type: plain (default), lvm, or btrfs.
	Type PartitionType `json:"type"`
}

// PartitionSubvolumes defines model for partition_subvolumes.
type PartitionSubvolumes struct {
	// Mountpoint Mount point of the partition. Must start with a slash.
	Mountpoint StorageMountpoint `json:"mountpoint,omitempty"`

	// Name Subvolume name, must also define its parent volume.
	Name string `json:"name,omitempty"`
}

// PartitionType Partition type: plain (default), lvm, or btrfs.
type PartitionType string

// Registration Registration details for various registration types, namely Red Hat
// Subscription Manager.
type Registration struct {
	// RegistrationFDO FDO allows users to configure FIDO Device Onboard device initialization
	// parameters. It is only available with the edge-simplified-installer or
	// iot-simplified-installer image types.
	RegistrationFDO *RegistrationFDO `json:"fdo,omitempty"`

	// RegistrationRedHat Registration details for Red Hat operating system images.
	RegistrationRedHat *RegistrationRedHat `json:"redhat,omitempty"`
}

// RegistrationConnector Red Hat console.redhat.com connector (rhc) details.
type RegistrationConnector struct {
	// Enabled Enables rhc (Red Hat Connector) during boot.
	Enabled bool `json:"enabled"`
}

// RegistrationFDO FDO allows users to configure FIDO Device Onboard device initialization
// parameters. It is only available with the edge-simplified-installer or
// iot-simplified-installer image types.
type RegistrationFDO struct {
	// DiMfgStringTypeMacIface Optional interface name for the MAC address.
	DiMfgStringTypeMacIface string `json:"di_mfg_string_type_mac_iface,omitempty"`

	// DiunPubKeyHash FDO server public key hex-encoded hash. Cannot be used together with insecure option or root certs.
	DiunPubKeyHash string `json:"diun_pub_key_hash,omitempty"`

	// DiunPubKeyInsecure FDO insecure option. When set, both hash or root certs must not be set.
	DiunPubKeyInsecure bool `json:"diun_pub_key_insecure,omitempty"`

	// DiunPubKeyRootCerts FDO server public key root certificate path. Cannot be used together with insecure option or hash.
	DiunPubKeyRootCerts string `json:"diun_pub_key_root_certs,omitempty"`

	// ManufacturingServerUrl FDO manufacturing server URL.
	ManufacturingServerUrl string `json:"manufacturing_server_url"`
}

// RegistrationInsights Red Hat Insights client details.
type RegistrationInsights struct {
	// Enabled Enables insights client during boot.
	Enabled bool `json:"enabled"`
}

// RegistrationRedHat Registration details for Red Hat operating system images.
type RegistrationRedHat struct {
	// ActivationKey Subscription manager activation key to use during registration.
	// A list of keys to use to redeem or apply specific subscriptions to the system.
	ActivationKey string `json:"activation_key,omitempty"`

	// Connector Red Hat console.redhat.com connector (rhc) details.
	Connector *RegistrationConnector `json:"connector,omitempty"`

	// Insights Red Hat Insights client details.
	Insights *RegistrationInsights `json:"insights,omitempty"`

	// Organization Subscription manager organization name to use during registration.
	Organization string `json:"organization,omitempty"`

	// RegistrationRHSM Subscription manager details (internal use only). The customization
	// expects that subscription-manager package is installed in the image, which
	// is by default part of the RHEL distribution bootable images. To explicitly
	// install the package, add it to the packages section in the blueprint.
	// The customization is not supported on Fedora distribution images.
	RegistrationRHSM *RegistrationRHSM `json:"subscription_manager,omitempty"`
}

// RegistrationRHSM Subscription manager details (internal use only). The customization
// expects that subscription-manager package is installed in the image, which
// is by default part of the RHEL distribution bootable images. To explicitly
// install the package, add it to the packages section in the blueprint.
// The customization is not supported on Fedora distribution images.
type RegistrationRHSM struct {
	// AutoRegistration Enabled auto_registration plugin configuration.
	AutoRegistration bool `json:"auto_registration"`

	// Enabled Enables the subscription-manager DNF plugin.
	Enabled bool `json:"enabled"`

	// ProductPluginEnabled Enables the product-id DNF plugin.
	ProductPluginEnabled bool `json:"product_plugin_enabled"`

	// RepositoryManagement Enabled repository_management plugin configuration.
	RepositoryManagement bool `json:"repository_management"`
}

// Storage Disk partitioning details. Not available for installer-based images.
//
// General principles:
//
// 1. All sizes, whether for specific filesystems, partitions, logical volumes,
// or the image itself, are treated as minimum requirements. This means the full
// disk image size is always larger than the size of the sum of the partitions,
// due to requirements for headers and metadata.
//
// 2. The partition that contains the root filesystem, whether this is a plain
// formatted partition, an LVM Volume Group, or a Btrfs partition, is always last
// in the partition table layout when it is automatically added. For Disk
// customizations the user-defined order is respected.
//
// 3. In the case of raw partitioning (no LVM and no Btrfs), the partition
// containing the root filesystem is grown to fill any left over space on the
// partition table. Logical Volumes are not grown to fill the space in the Volume
// Group since they are trivial to grow on a live system.
type Storage struct {
	// Minsize Minimum size of the storage device. When not set, the image size is acquired
	// from image request.
	//
	// Size must be formatted as an integer followed by whitespace and then either
	// a decimal unit (B, KB/kB, MB, GB, TB, PB, EB) or binary unit (KiB, MiB, GiB,
	// TiB, PiB, EiB).
	Minsize string `json:"minsize"`

	// Partitions Partitions of the following types: plain (default), lvm, or btrfs.
	Partitions []StoragePartition `json:"partitions"`

	// Type Device partitioning type: gpt (default) or mbr.
	Type StorageType `json:"type"`
}

// FSType File system type: ext4 (default), xfs, swap, or vfat.
//
// Relevant for partition types: plain.
type FSType string

// StorageMinsize Minimum size of the volume.
//
// Size must be formatted as an integer followed by whitespace and then either a
// decimal unit (B, KB/kB, MB, GB, TB, PB, EB) or binary unit (KiB, MiB, GiB,
// TiB, PiB, EiB).
type StorageMinsize = string

// StorageMountpoint Mount point of the partition. Must start with a slash.
type StorageMountpoint = string

// StoragePartition Partitions of the following types: plain (default), lvm, or btrfs.
type StoragePartition struct {
	union json.RawMessage
}

// StorageType Device partitioning type: gpt (default) or mbr.
type StorageType string

// Systemd Systemd unit configuration.
//
// This section can be used to control which services are enabled at boot time.
// Some image types already have services enabled or disabled in order for the image
// to work correctly, and cannot be overridden. For example, ami image type requires
// sshd, chronyd, and cloud-init services. Blueprint services do not replace these
// services, but add them to the list of services already present in the templates,
// if any.
type Systemd struct {
	// Disabled The disabled attribute is a list of strings that contains the systemd units to be disabled.
	Disabled []string `json:"disabled,omitempty"`

	// Enabled The enabled attribute is a list of strings that contains the systemd units to be enabled.
	Enabled []string `json:"enabled,omitempty"`

	// Masked The masked attribute is a list of strings that contains the systemd units to be masked.
	Masked []string `json:"masked,omitempty"`
}

// TailoringJSON defines model for tailoring_json.
type TailoringJSON struct {
	// JSONFilePath JSON filepath, must be used with json_profile_id and cannot be used with selected and unselected fields.
	JSONFilePath string `json:"json_filepath"`

	// JSONProfileID JSON profile ID, must be used with json_filepath and cannot be used with selected and unselected fields.
	JSONProfileID string `json:"json_profile_id"`
}

// TailoringProfiles defines model for tailoring_profiles.
type TailoringProfiles struct {
	// Selected Selected rules, cannot be used with json_profile_id and json_filepath.
	Selected []string `json:"selected,omitempty"`

	// Unselected Unselected rules, cannot be used with json_profile_id and json_filepath.
	Unselected []string `json:"unselected,omitempty"`
}

// TimeDate Time and date details allowing configuration of the timezone and
// NTP servers. The timezone is set by default to UTC.
type TimeDate struct {
	// NtpServers An optional list of strings containing NTP servers to use. If
	// not provided the distribution defaults are used.
	NtpServers []string `json:"ntp_servers,omitempty"`

	// Timezone System time zone. Defaults to UTC. To list available time zones run:
	//
	// timedatectl list-timezones
	Timezone string `json:"timezone"`
}

// ValidateBlueprintJSONRequestBody defines body for ValidateBlueprint for application/json ContentType.
type ValidateBlueprintJSONRequestBody = Blueprint

// AsIgnitionUrl returns the union data inside the Ignition as a IgnitionUrl
func (t Ignition) AsIgnitionUrl() (IgnitionUrl, error) {
	var body IgnitionUrl
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIgnitionUrl overwrites any union data inside the Ignition as the provided IgnitionUrl
func (t *Ignition) FromIgnitionUrl(v IgnitionUrl) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIgnitionUrl performs a merge with any union data inside the Ignition, using the provided IgnitionUrl
func (t *Ignition) MergeIgnitionUrl(v IgnitionUrl) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIgnitionText returns the union data inside the Ignition as a IgnitionText
func (t Ignition) AsIgnitionText() (IgnitionText, error) {
	var body IgnitionText
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIgnitionText overwrites any union data inside the Ignition as the provided IgnitionText
func (t *Ignition) FromIgnitionText(v IgnitionText) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIgnitionText performs a merge with any union data inside the Ignition, using the provided IgnitionText
func (t *Ignition) MergeIgnitionText(v IgnitionText) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Ignition) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Ignition) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDnfSourceBaseUrls returns the union data inside the DNFSource as a DnfSourceBaseUrls
func (t DNFSource) AsDnfSourceBaseUrls() (DnfSourceBaseUrls, error) {
	var body DnfSourceBaseUrls
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDnfSourceBaseUrls overwrites any union data inside the DNFSource as the provided DnfSourceBaseUrls
func (t *DNFSource) FromDnfSourceBaseUrls(v DnfSourceBaseUrls) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDnfSourceBaseUrls performs a merge with any union data inside the DNFSource, using the provided DnfSourceBaseUrls
func (t *DNFSource) MergeDnfSourceBaseUrls(v DnfSourceBaseUrls) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDnfSourceMetalink returns the union data inside the DNFSource as a DnfSourceMetalink
func (t DNFSource) AsDnfSourceMetalink() (DnfSourceMetalink, error) {
	var body DnfSourceMetalink
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDnfSourceMetalink overwrites any union data inside the DNFSource as the provided DnfSourceMetalink
func (t *DNFSource) FromDnfSourceMetalink(v DnfSourceMetalink) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDnfSourceMetalink performs a merge with any union data inside the DNFSource, using the provided DnfSourceMetalink
func (t *DNFSource) MergeDnfSourceMetalink(v DnfSourceMetalink) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDnfSourceMirrorlist returns the union data inside the DNFSource as a DnfSourceMirrorlist
func (t DNFSource) AsDnfSourceMirrorlist() (DnfSourceMirrorlist, error) {
	var body DnfSourceMirrorlist
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDnfSourceMirrorlist overwrites any union data inside the DNFSource as the provided DnfSourceMirrorlist
func (t *DNFSource) FromDnfSourceMirrorlist(v DnfSourceMirrorlist) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDnfSourceMirrorlist performs a merge with any union data inside the DNFSource, using the provided DnfSourceMirrorlist
func (t *DNFSource) MergeDnfSourceMirrorlist(v DnfSourceMirrorlist) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t DNFSource) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DNFSource) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFsnodeContentsText returns the union data inside the FSNodeContents as a FsnodeContentsText
func (t FSNodeContents) AsFsnodeContentsText() (FsnodeContentsText, error) {
	var body FsnodeContentsText
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFsnodeContentsText overwrites any union data inside the FSNodeContents as the provided FsnodeContentsText
func (t *FSNodeContents) FromFsnodeContentsText(v FsnodeContentsText) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFsnodeContentsText performs a merge with any union data inside the FSNodeContents, using the provided FsnodeContentsText
func (t *FSNodeContents) MergeFsnodeContentsText(v FsnodeContentsText) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFsnodeContentsBase64 returns the union data inside the FSNodeContents as a FsnodeContentsBase64
func (t FSNodeContents) AsFsnodeContentsBase64() (FsnodeContentsBase64, error) {
	var body FsnodeContentsBase64
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFsnodeContentsBase64 overwrites any union data inside the FSNodeContents as the provided FsnodeContentsBase64
func (t *FSNodeContents) FromFsnodeContentsBase64(v FsnodeContentsBase64) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFsnodeContentsBase64 performs a merge with any union data inside the FSNodeContents, using the provided FsnodeContentsBase64
func (t *FSNodeContents) MergeFsnodeContentsBase64(v FsnodeContentsBase64) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t FSNodeContents) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FSNodeContents) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFirewallService returns the union data inside the NetworkService as a FirewallService
func (t NetworkService) AsFirewallService() (FirewallService, error) {
	var body FirewallService
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFirewallService overwrites any union data inside the NetworkService as the provided FirewallService
func (t *NetworkService) FromFirewallService(v FirewallService) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFirewallService performs a merge with any union data inside the NetworkService, using the provided FirewallService
func (t *NetworkService) MergeFirewallService(v FirewallService) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFirewallPort returns the union data inside the NetworkService as a FirewallPort
func (t NetworkService) AsFirewallPort() (FirewallPort, error) {
	var body FirewallPort
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFirewallPort overwrites any union data inside the NetworkService as the provided FirewallPort
func (t *NetworkService) FromFirewallPort(v FirewallPort) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFirewallPort performs a merge with any union data inside the NetworkService, using the provided FirewallPort
func (t *NetworkService) MergeFirewallPort(v FirewallPort) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFirewallFromTo returns the union data inside the NetworkService as a FirewallFromTo
func (t NetworkService) AsFirewallFromTo() (FirewallFromTo, error) {
	var body FirewallFromTo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFirewallFromTo overwrites any union data inside the NetworkService as the provided FirewallFromTo
func (t *NetworkService) FromFirewallFromTo(v FirewallFromTo) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFirewallFromTo performs a merge with any union data inside the NetworkService, using the provided FirewallFromTo
func (t *NetworkService) MergeFirewallFromTo(v FirewallFromTo) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t NetworkService) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NetworkService) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsTailoringJSON returns the union data inside the OpenSCAPTailoring as a TailoringJSON
func (t OpenSCAPTailoring) AsTailoringJSON() (TailoringJSON, error) {
	var body TailoringJSON
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTailoringJSON overwrites any union data inside the OpenSCAPTailoring as the provided TailoringJSON
func (t *OpenSCAPTailoring) FromTailoringJSON(v TailoringJSON) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTailoringJSON performs a merge with any union data inside the OpenSCAPTailoring, using the provided TailoringJSON
func (t *OpenSCAPTailoring) MergeTailoringJSON(v TailoringJSON) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTailoringProfiles returns the union data inside the OpenSCAPTailoring as a TailoringProfiles
func (t OpenSCAPTailoring) AsTailoringProfiles() (TailoringProfiles, error) {
	var body TailoringProfiles
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTailoringProfiles overwrites any union data inside the OpenSCAPTailoring as the provided TailoringProfiles
func (t *OpenSCAPTailoring) FromTailoringProfiles(v TailoringProfiles) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTailoringProfiles performs a merge with any union data inside the OpenSCAPTailoring, using the provided TailoringProfiles
func (t *OpenSCAPTailoring) MergeTailoringProfiles(v TailoringProfiles) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OpenSCAPTailoring) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OpenSCAPTailoring) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPartitionPlain returns the union data inside the StoragePartition as a PartitionPlain
func (t StoragePartition) AsPartitionPlain() (PartitionPlain, error) {
	var body PartitionPlain
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPartitionPlain overwrites any union data inside the StoragePartition as the provided PartitionPlain
func (t *StoragePartition) FromPartitionPlain(v PartitionPlain) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePartitionPlain performs a merge with any union data inside the StoragePartition, using the provided PartitionPlain
func (t *StoragePartition) MergePartitionPlain(v PartitionPlain) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPartitionLvm returns the union data inside the StoragePartition as a PartitionLvm
func (t StoragePartition) AsPartitionLvm() (PartitionLvm, error) {
	var body PartitionLvm
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPartitionLvm overwrites any union data inside the StoragePartition as the provided PartitionLvm
func (t *StoragePartition) FromPartitionLvm(v PartitionLvm) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePartitionLvm performs a merge with any union data inside the StoragePartition, using the provided PartitionLvm
func (t *StoragePartition) MergePartitionLvm(v PartitionLvm) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPartitionBtrfs returns the union data inside the StoragePartition as a PartitionBtrfs
func (t StoragePartition) AsPartitionBtrfs() (PartitionBtrfs, error) {
	var body PartitionBtrfs
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPartitionBtrfs overwrites any union data inside the StoragePartition as the provided PartitionBtrfs
func (t *StoragePartition) FromPartitionBtrfs(v PartitionBtrfs) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePartitionBtrfs performs a merge with any union data inside the StoragePartition, using the provided PartitionBtrfs
func (t *StoragePartition) MergePartitionBtrfs(v PartitionBtrfs) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StoragePartition) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StoragePartition) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
